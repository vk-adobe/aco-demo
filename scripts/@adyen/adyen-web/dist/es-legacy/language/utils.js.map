{"version":3,"file":"utils.js","sources":["../../../src/language/utils.ts"],"sourcesContent":["import { h } from 'preact';\nimport { CustomTranslations } from './types';\nimport AdyenCheckoutError from '../core/Errors/AdyenCheckoutError';\n\n/**\n * Returns a locale with the proper format\n *\n * @example\n * formatLocale('En_us'); -> en-US\n * formatLocale('ar') -> ar\n */\nexport function formatLocale(localeParam: string): string {\n    const locale = localeParam.replace('_', '-');\n    const format = new RegExp('([a-z]{2})([-])([A-Z]{2})');\n\n    // If it's already formatted, return the locale\n    if (format.test(locale)) {\n        return locale;\n    }\n\n    // If no country code is defined (Ex: 'ar') , then returns 'ar'\n    const [languageCode, countryCode] = locale.split('-');\n    if (languageCode.length !== 2) {\n        throw new AdyenCheckoutError('IMPLEMENTATION_ERROR', `Locale '${localeParam}' does not match the expected format`);\n    }\n    if (!countryCode) {\n        return languageCode.toLowerCase();\n    }\n\n    // Ensure correct format and join the strings back together\n    const fullLocale = [languageCode.toLowerCase(), countryCode.toUpperCase()].join('-');\n    if (format.test(fullLocale)) {\n        return fullLocale;\n    } else {\n        throw new AdyenCheckoutError('IMPLEMENTATION_ERROR', `Locale '${localeParam}' does not match the expected format`);\n    }\n}\n\n/**\n * Makes sure that if custom translation is defined using not properly formatted locale keys, then it gets formatted correctly\n * Ex: Custom translation defined as { en_US: { ... }} will be adjusted to { 'en-US': { ... }}\n */\nexport function formatCustomTranslations(customTranslations: CustomTranslations = {}): CustomTranslations {\n    return Object.keys(customTranslations).reduce((memo, customTranslationLocaleKey) => {\n        const locale = formatLocale(customTranslationLocaleKey);\n        memo[locale] = customTranslations[customTranslationLocaleKey];\n        return memo;\n    }, {});\n}\n\nconst replaceTranslationValues = (translation, values) => {\n    return translation.replace(/%{(\\w+)}/g, (_, k) => values[k] || '');\n};\n\n/**\n * Returns a translation string by key\n * @param translations -\n * @param key -\n * @param options -\n *\n * @internal\n */\nexport const getTranslation = (translations: object, key: string, options: { [key: string]: any } = { values: {}, count: 0 }): string => {\n    const keyPlural = `${key}__plural`;\n    const keyForCount = count => `${key}__${count}`;\n\n    if (Object.prototype.hasOwnProperty.call(translations, keyForCount(options.count))) {\n        // Find key__count translation key\n        return replaceTranslationValues(translations[keyForCount(options.count)], options.values);\n    } else if (Object.prototype.hasOwnProperty.call(translations, keyPlural) && options.count > 1) {\n        // Find key__plural translation key, if count greater than 1 (e.g. myTranslation__plural)\n        return replaceTranslationValues(translations[keyPlural], options.values);\n    } else if (Object.prototype.hasOwnProperty.call(translations, key)) {\n        // Find key translation key (e.g. myTranslation)\n        return replaceTranslationValues(translations[key], options.values);\n    }\n\n    return null;\n};\n\n/**\n * Injects JSX elements in a middle of a translation and returns a JSX array\n * The input string should use %# as the token to know where to insert the component\n * @param translation - Translation string\n * @param renderFunctions - An array function that renders JSX elements\n */\nexport const interpolateElement = (translation: string, renderFunctions: Array<(translation: string) => h.JSX.Element | string>) => {\n    // splits by regex group, it guarantees that it only splits with 2 tokens (%#)\n    const matches = translation.split(/%#(.*?)%#/gm);\n\n    if (renderFunctions.length !== Math.floor(matches.length / 2)) {\n        throw Error('The number of functions provided does not match the number of elements in the translation string.');\n    }\n\n    // the map will create an array of JSX / string elements, this syntax in accepted in JSX/react to render elements\n    return matches.map((term, index) => {\n        // math to get the index of the renderFunction that should be used\n        // since we split on tokens, that means the index of the render function is half of the index of the string\n        const indexInFunctionArray = Math.floor(index / 2);\n        return index % 2 === 0 ? term : renderFunctions[indexInFunctionArray](term);\n    });\n};\n"],"names":["formatLocale","localeParam","locale","replace","format","RegExp","test","languageCode","countryCode","split","length","AdyenCheckoutError","toLowerCase","fullLocale","toUpperCase","join","formatCustomTranslations","customTranslations","Object","keys","reduce","memo","customTranslationLocaleKey","replaceTranslationValues","translation","values","_","k","getTranslation","translations","key","options","count","keyPlural","keyForCount","prototype","hasOwnProperty","call","interpolateElement","renderFunctions","matches","Math","floor","Error","map","term","index","indexInFunctionArray"],"mappings":"8FAWO,SAASA,EAAaC,GACzB,MAAMC,EAASD,EAAYE,QAAQ,IAAK,KAClCC,EAAS,IAAIC,OAAO,6BAG1B,GAAID,EAAOE,KAAKJ,GACZ,OAAOA,EAIX,MAAOK,EAAcC,GAAeN,EAAOO,MAAM,KACjD,GAA4B,IAAxBF,EAAaG,OACb,MAAM,IAAIC,EAAmB,uBAAwB,WAAWV,yCAEpE,IAAKO,EACD,OAAOD,EAAaK,cAIxB,MAAMC,EAAa,CAACN,EAAaK,cAAeJ,EAAYM,eAAeC,KAAK,KAChF,GAAIX,EAAOE,KAAKO,GACZ,OAAOA,EAEP,MAAM,IAAIF,EAAmB,uBAAwB,WAAWV,wCAExE,CAMO,SAASe,EAAyBC,EAAyC,IAC9E,OAAOC,OAAOC,KAAKF,GAAoBG,QAAO,CAACC,EAAMC,KAEjDD,EADerB,EAAasB,IACbL,EAAmBK,GAC3BD,IACR,GACP,CAEA,MAAME,EAA2B,CAACC,EAAaC,IACpCD,EAAYrB,QAAQ,aAAa,CAACuB,EAAGC,IAAMF,EAAOE,IAAM,KAWtDC,EAAiB,CAACC,EAAsBC,EAAaC,EAAkC,CAAEN,OAAQ,CAAC,EAAGO,MAAO,MACrH,MAAMC,EAAY,GAAGH,YACfI,EAAcF,GAAS,GAAGF,MAAQE,IAExC,OAAId,OAAOiB,UAAUC,eAAeC,KAAKR,EAAcK,EAAYH,EAAQC,QAEhET,EAAyBM,EAAaK,EAAYH,EAAQC,QAASD,EAAQN,QAC3EP,OAAOiB,UAAUC,eAAeC,KAAKR,EAAcI,IAAcF,EAAQC,MAAQ,EAEjFT,EAAyBM,EAAaI,GAAYF,EAAQN,QAC1DP,OAAOiB,UAAUC,eAAeC,KAAKR,EAAcC,GAEnDP,EAAyBM,EAAaC,GAAMC,EAAQN,QAGxD,IAAA,EASEa,EAAqB,CAACd,EAAqBe,KAEpD,MAAMC,EAAUhB,EAAYf,MAAM,eAElC,GAAI8B,EAAgB7B,SAAW+B,KAAKC,MAAMF,EAAQ9B,OAAS,GACvD,MAAMiC,MAAM,qGAIhB,OAAOH,EAAQI,KAAI,CAACC,EAAMC,KAGtB,MAAMC,EAAuBN,KAAKC,MAAMI,EAAQ,GAChD,OAAOA,EAAQ,GAAM,EAAID,EAAON,EAAgBQ,GAAsBF,EAAAA,GAC1E"}