{"version":3,"file":"Analytics.js","sources":["../../../../src/core/Analytics/Analytics.ts"],"sourcesContent":["import CollectId from '../Services/analytics/collect-id';\nimport EventsQueue, { EventsQueueModule } from './EventsQueue';\nimport { AnalyticsEventCategory, AnalyticsInitialEvent, AnalyticsObject, AnalyticsProps } from './types';\nimport { ANALYTIC_LEVEL, ANALYTICS_INFO_TIMER_INTERVAL, ANALYTICS_PATH, ANALYTICS_EVENT } from './constants';\nimport { debounce } from '../../utils/debounce';\nimport { AnalyticsModule } from '../../types/global-types';\nimport { processAnalyticsData } from './utils';\nimport { AnalyticsEvent } from './AnalyticsEvent';\n\nlet capturedCheckoutAttemptId = null;\nlet sendEventsTimerId = null;\n\nconst Analytics = ({ locale, clientKey, analytics, amount, analyticsContext, bundleType }: AnalyticsProps): AnalyticsModule => {\n    const defaultProps = {\n        enabled: true,\n        checkoutAttemptId: null,\n        analyticsData: {}\n    };\n\n    const props = { ...defaultProps, ...analytics };\n\n    const collectId = CollectId({ analyticsContext, clientKey, locale, amount, analyticsPath: ANALYTICS_PATH, bundleType });\n    const eventsQueue: EventsQueueModule = EventsQueue({ analyticsContext, clientKey, analyticsPath: ANALYTICS_PATH });\n\n    const sendAnalyticsEvents = () => {\n        if (capturedCheckoutAttemptId) {\n            return eventsQueue.run(capturedCheckoutAttemptId);\n        }\n        return Promise.resolve(null);\n    };\n\n    const addAnalyticsEvent = (eventCat: AnalyticsEventCategory, obj: AnalyticsObject) => {\n        const arrayName = eventCat === ANALYTICS_EVENT.info ? eventCat : `${eventCat}s`;\n        eventsQueue.add(`${arrayName}`, obj);\n\n        /**\n         * The logic is:\n         *  - info events are stored until a log or error comes along,\n         *  but, if after a set time, no other analytics event (log or error) has come along then we send the info events anyway\n         */\n        if (eventCat === ANALYTICS_EVENT.info) {\n            clearTimeout(sendEventsTimerId);\n            sendEventsTimerId = setTimeout(() => void sendAnalyticsEvents(), ANALYTICS_INFO_TIMER_INTERVAL);\n        }\n\n        /**\n         * The logic is:\n         *  - errors and logs get sent straightaway\n         *  ...but... tests with the 3DS2 process show that many logs can happen almost at the same time (or you can have an error followed immediately by a log),\n         *  so instead of making several sequential api calls we see if we can \"batch\" them using debounce\n         */\n        if (eventCat === ANALYTICS_EVENT.log || eventCat === ANALYTICS_EVENT.error) {\n            clearTimeout(sendEventsTimerId); // clear any timer that might be about to dispatch the info events array\n\n            debounce(sendAnalyticsEvents)();\n        }\n    };\n\n    return {\n        /**\n         * Make \"setup\" call, to pass containerWidth, buildType, channel etc, and receive a checkoutAttemptId in return\n         * @param initialEvent -\n         */\n        setUp: async (initialEvent: AnalyticsInitialEvent) => {\n            const { payload, enabled } = props; // TODO what is payload, is it ever used?\n            const level = enabled ? ANALYTIC_LEVEL.all : ANALYTIC_LEVEL.initial;\n            const analyticsData = processAnalyticsData(props.analyticsData);\n            if (!capturedCheckoutAttemptId) {\n                try {\n                    capturedCheckoutAttemptId = await collectId({\n                        ...initialEvent,\n                        ...(payload && { ...payload }),\n                        ...(Object.keys(analyticsData).length && { ...analyticsData }),\n                        ...{ level }\n                    });\n                } catch (e: any) {\n                    console.warn(`Fetching checkoutAttemptId failed.${e ? ` Error=${e}` : ''}`);\n                }\n            }\n        },\n\n        getCheckoutAttemptId: (): string => capturedCheckoutAttemptId,\n\n        // Expose getter for testing purposes\n        getEventsQueue: () => eventsQueue,\n\n        getEnabled: () => props.enabled,\n\n        sendAnalytics: (analyticsObj: AnalyticsEvent): boolean => {\n            if (!props.enabled) return false;\n\n            const eventCategory: AnalyticsEventCategory = analyticsObj.getEventCategory();\n\n            addAnalyticsEvent(eventCategory, analyticsObj);\n\n            return true;\n        }\n    } as AnalyticsModule;\n};\n\nexport default Analytics;\n"],"names":["capturedCheckoutAttemptId","sendEventsTimerId","Analytics","locale","clientKey","analytics","amount","analyticsContext","bundleType","props","_object_spread","enabled","checkoutAttemptId","analyticsData","collectId","CollectId","analyticsPath","ANALYTICS_PATH","eventsQueue","EventsQueue","sendAnalyticsEvents","run","Promise","resolve","setUp","async","initialEvent","payload","level","ANALYTIC_LEVEL","all","initial","processAnalyticsData","Object","keys","length","e","console","warn","getCheckoutAttemptId","getEventsQueue","getEnabled","sendAnalytics","analyticsObj","eventCat","obj","arrayName","ANALYTICS_EVENT","info","add","clearTimeout","setTimeout","ANALYTICS_INFO_TIMER_INTERVAL","log","error","debounce","addAnalyticsEvent","getEventCategory"],"mappings":"ovBASA,IAAIA,EAA4B,KAC5BC,EAAoB,KAExB,MAAMC,EAAY,EAAGC,SAAQC,YAAWC,YAAWC,SAAQC,mBAAkBC,iBACzE,MAMMC,EAAQC,KANO,CACjBC,SAAS,EACTC,kBAAmB,KACnBC,cAAe,CAAA,GAGiBR,GAE9BS,EAAYC,EAAU,CAAER,mBAAkBH,YAAWD,SAAgBa,cAAeC,EAAgBT,eACpGU,EAAiCC,EAAY,CAAEZ,mBAAkBH,YAAWY,cAAeC,IAE3FG,EAAsB,IACpBpB,EACOkB,EAAYG,IAAIrB,GAEpBsB,QAAQC,QAAQ,MA8B3B,MAAO,CAKHC,MAAOC,MAAOC,IACV,MAAMC,QAAEA,EAAOhB,QAAEA,GAAYF,EACvBmB,EAAQjB,EAAUkB,EAAeC,IAAMD,EAAeE,QACtDlB,EAAgBmB,EAAqBvB,EAAMI,eACjD,IAAKb,EACD,IACIA,QAAkCc,EAAUJ,EACrCgB,CAAAA,EAAAA,EACCC,GAAWjB,EAAKiB,CAAAA,EAAAA,GAChBM,OAAOC,KAAKrB,GAAesB,QAAUzB,KAAKG,GAC3C,CAAEe,UAEb,CAAE,MAAOQ,GACLC,QAAQC,KAAK,sCAAqCF,EAAI,UAAUA,IAAM,IAC1E,CACJ,EAGJG,qBAAsB,IAAcvC,EAGpCwC,eAAgB,IAAMtB,EAEtBuB,WAAY,IAAMhC,EAAME,QAExB+B,cAAgBC,IACZ,IAAKlC,EAAME,QAAS,OAAO,EAM3B,MAhEkB,EAACiC,EAAkCC,KACzD,MAAMC,EAAYF,IAAaG,EAAgBC,KAAOJ,EAAW,GAAGA,KACpE1B,EAAY+B,IAAI,GAAGH,IAAaD,GAO5BD,IAAaG,EAAgBC,OAC7BE,aAAajD,GACbA,EAAoBkD,YAAW,KAAW/B,GAAuBgC,GAAAA,IASjER,IAAaG,EAAgBM,KAAOT,IAAaG,EAAgBO,QACjEJ,aAAajD,GAEbsD,EAASnC,EAATmC,GACJ,EAsCIC,CAF8Cb,EAAac,mBAE1Bd,IAE1B,CAAA,EAEf"}