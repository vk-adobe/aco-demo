{"version":3,"file":"useSRPanelForCardInputErrors.js","sources":["../../../../../../src/components/Card/components/CardInput/useSRPanelForCardInputErrors.ts"],"sourcesContent":["import { useEffect, useState } from 'preact/hooks';\nimport useSRPanelContext from '../../../../core/Errors/useSRPanelContext';\nimport { SetSRMessagesReturnFn } from '../../../../core/Errors/SRPanelProvider';\nimport { handlePartialAddressMode, lookupBlurBasedErrors, mapFieldKey } from './utils';\nimport { usePrevious } from '../../../../utils/hookUtils';\nimport { SetSRMessagesReturnObject, SortedErrorObject } from '../../../../core/Errors/types';\nimport { ERROR_ACTION_BLUR_SCENARIO, ERROR_ACTION_FOCUS_FIELD } from '../../../../core/Errors/constants';\nimport { setFocusOnFirstField } from './handlers';\nimport { getArrayDifferences } from '../../../../utils/arrayUtils';\n\nconst useSRPanelForCardInputErrors = ({ errors, props, isValidating, retrieveLayout, specifications, billingAddress, sfp }) => {\n    // Extract fns from context\n    const { setSRMessagesFromObjects, setSRMessagesFromStrings, clearSRPanel, shouldMoveFocusSR } = useSRPanelContext();\n\n    // Generate a setSRMessages function - implemented as a partial, since the initial set of arguments don't change.\n    const setSRMessages: SetSRMessagesReturnFn = setSRMessagesFromObjects?.({\n        fieldTypeMappingFn: mapFieldKey\n    });\n\n    const partialAddressSchema = handlePartialAddressMode(props.billingAddressMode);\n\n    const [sortedErrorList, setSortedErrorList] = useState<SortedErrorObject[]>(null);\n\n    // Get the previous list of errors\n    const previousSortedErrors = usePrevious(sortedErrorList);\n\n    const sfStateErrorsObj = sfp.current?.mapErrorsToValidationRuleResult();\n    const mergedErrors = { ...errors, ...sfStateErrorsObj };\n\n    useEffect(() => {\n        try {\n            // Extract and then flatten billingAddress errors into a new object with *all* the field errors at top level\n            const { billingAddress: extractedAddressErrors, ...errorsWithoutAddress } = mergedErrors;\n\n            const errorsForPanel = { ...errorsWithoutAddress, ...extractedAddressErrors };\n\n            // Pass dynamic props (errors, layout etc) to SRPanel via partial\n            const srPanelResp: SetSRMessagesReturnObject = setSRMessages?.({\n                errors: errorsForPanel,\n                isValidating: isValidating.current,\n                layout: retrieveLayout(),\n                // If we don't have country specific address labels, we might have a label related to a partialAddressSchema (i.e. zipCode)\n                countrySpecificLabels: specifications.getAddressLabelsForCountry(billingAddress?.country) ?? partialAddressSchema?.default?.labels\n            });\n\n            // Store the array of sorted error objects separately so that we can use it to make comparisons between the old and new arrays\n            const currentErrorsSortedByLayout = srPanelResp?.currentErrorsSortedByLayout;\n            setSortedErrorList(currentErrorsSortedByLayout);\n\n            /**\n             * Need extra actions after setting SRPanel messages in order to focus field (if required) and because we have some errors that are fired onBlur\n             */\n            switch (srPanelResp?.action) {\n                // A call to focus the first field in error will always follow the call to validate the whole form\n                case ERROR_ACTION_FOCUS_FIELD:\n                    if (shouldMoveFocusSR) setFocusOnFirstField(isValidating.current, sfp, srPanelResp?.fieldToFocus);\n                    // Remove 'showValidation' mode - allowing time for collation of all the fields in error whilst it is 'showValidation' mode (some errors come in a second render pass)\n                    setTimeout(() => {\n                        isValidating.current = false;\n                    }, 300);\n                    break;\n\n                /**\n                 * Relates to errors triggered by a field blurring (some pm forms have this, some don't) - check if there is an error to either set or to clear\n                 */\n                case ERROR_ACTION_BLUR_SCENARIO: {\n                    const difference = getArrayDifferences<SortedErrorObject, string>(currentErrorsSortedByLayout, previousSortedErrors, 'field');\n\n                    const latestErrorMsg = difference?.[0];\n\n                    if (latestErrorMsg) {\n                        // Use the error code to look up whether error is actually a blur based one (most are but some SF ones aren't)\n                        const isBlurBasedError = lookupBlurBasedErrors(latestErrorMsg.errorCode);\n\n                        /**\n                         *  ONLY ADD BLUR BASED ERRORS TO THE ERROR PANEL - doing this step prevents the non-blur based errors from being read out twice\n                         *  (once from the aria-live, error panel & once from the aria-describedby element)\n                         */\n                        const latestSRError = isBlurBasedError ? latestErrorMsg.errorMessage : null;\n                        // console.log('### CardInput2::componentDidUpdate:: #2 (not validating) single error:: latestSRError', latestSRError);\n                        setSRMessagesFromStrings(latestSRError);\n                    } else {\n                        // called when previousSortedErrors.length >= currentErrorsSortedByLayout.length\n                        // console.log('### CardInput2::componentDidUpdate:: #3(not validating) clearing errors:: NO latestErrorMsg');\n                        clearSRPanel();\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        } catch (_) {\n            // We don't handle the error related to the sr panel, let it fail silently.\n        }\n    }, [errors]);\n\n    return { sortedErrorList, previousSortedErrors, clearSRPanel };\n};\n\nexport default useSRPanelForCardInputErrors;\n"],"names":["useSRPanelForCardInputErrors","errors","props","isValidating","retrieveLayout","specifications","billingAddress","sfp","setSRMessagesFromObjects","setSRMessagesFromStrings","clearSRPanel","shouldMoveFocusSR","useSRPanelContext","setSRMessages","fieldTypeMappingFn","mapFieldKey","partialAddressSchema","handlePartialAddressMode","billingAddressMode","sortedErrorList","setSortedErrorList","useState","previousSortedErrors","usePrevious","mergedErrors","_object_spread","current","mapErrorsToValidationRuleResult","useEffect","extractedAddressErrors","errorsForPanel","srPanelResp","layout","countrySpecificLabels","getAddressLabelsForCountry","country","default","labels","currentErrorsSortedByLayout","action","ERROR_ACTION_FOCUS_FIELD","setFocusOnFirstField","fieldToFocus","setTimeout","ERROR_ACTION_BLUR_SCENARIO","difference","getArrayDifferences","latestErrorMsg","latestSRError","lookupBlurBasedErrors","errorCode","errorMessage","_"],"mappings":"o1CAUA,MAAMA,EAA+B,EAAGC,SAAQC,QAAOC,eAAcC,iBAAgBC,iBAAgBC,iBAAgBC,UAgBxFA,IAAAA,EAdzB,MAAMC,yBAAEA,EAAwBC,yBAAEA,EAAwBC,aAAEA,EAAYC,kBAAEA,GAAsBC,IAG1FC,EAAuCL,aAAAA,EAAAA,EAA2B,CACpEM,mBAAoBC,IAGlBC,EAAuBC,EAAyBf,EAAMgB,qBAErDC,EAAiBC,GAAsBC,EAA8B,MAGtEC,EAAuBC,EAAYJ,GAGnCK,EAAeC,KAAKxB,EADDM,QAAAA,EAAAA,EAAImB,eAAJnB,IAAAA,OAAAA,EAAAA,EAAaoB,mCAsEtC,OAnEAC,GAAU,KACN,IAYqGZ,IAAAA,EAVjG,MAAQV,eAAgBuB,GAAoDL,EAEtEM,EAAiBL,KAFqDD,EAAAA,EAAAA,CAApElB,mBAE6CuB,GAQ1BxB,IAAAA,EAL3B,MAAM0B,EAAyClB,aAAAA,EAAAA,EAAgB,CAC3DZ,OAAQ6B,EACR3B,aAAcA,EAAauB,QAC3BM,OAAQ5B,IAER6B,sBAAwF,QAAjE5B,EAAAA,EAAe6B,2BAA2B5B,aAAAA,EAAAA,EAAgB6B,oBAA1D9B,EAAAA,EAAsEW,SAAAA,QAAAA,EAAAA,EAAsBoB,eAAtBpB,IAAAA,SAAAA,EAA+BqB,SAI1HC,EAA8BP,aAAAA,EAAAA,EAAaO,4BAMjD,OALAlB,EAAmBkB,GAKXP,aAAAA,EAAAA,EAAaQ,QAEjB,KAAKC,EACG7B,GAAmB8B,EAAqBtC,EAAauB,QAASnB,EAAKwB,aAAAA,EAAAA,EAAaW,cAEpFC,YAAW,KACPxC,EAAauB,SAAU,CAAA,GACxB,KACH,MAKJ,KAAKkB,EAA4B,CAC7B,MAAMC,EAAaC,EAA+CR,EAA6BhB,EAAsB,SAE/GyB,EAAiBF,aAAAA,EAAAA,EAAa,GAEpC,GAAIE,EAAgB,CAEhB,MAMMC,EANmBC,EAAsBF,EAAeG,WAMrBH,EAAeI,aAAe,KAEvE1C,EAAyBuC,QAIzBtC,IAEJ,KACJ,EAIR,CAAE,MAAO0C,GAET,IACD,CAACnD,IAEG,CAAEkB,kBAAiBG,uBAAsBZ,eAAa"}