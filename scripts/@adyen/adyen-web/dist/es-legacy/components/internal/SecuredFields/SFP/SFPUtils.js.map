{"version":3,"file":"SFPUtils.js","sources":["../../../../../../src/components/internal/SecuredFields/SFP/SFPUtils.ts"],"sourcesContent":["// ROUTINES USED IN SecuredFieldsProvider.componentDidMount TO DETECT & MAP FIELD NAMES ///////////\nimport {\n    CVC_POLICY_HIDDEN,\n    CVC_POLICY_OPTIONAL,\n    DATE_POLICY_HIDDEN,\n    DATE_POLICY_OPTIONAL,\n    ENCRYPTED_EXPIRY_DATE,\n    ENCRYPTED_EXPIRY_MONTH,\n    ENCRYPTED_EXPIRY_YEAR,\n    ENCRYPTED_SECURITY_CODE\n} from '../lib/constants';\nimport getProp from '../../../../utils/getProp';\nimport { EMPTY_FIELD_ERROR_MESSAGES } from '../../../../core/Errors/constants';\n\n/**\n * Make an array of encrypted field names based on the value of the 'data-cse' attribute of elements in the rootNode\n */\nexport const getFields = rootNode => {\n    if (rootNode) {\n        return Array.prototype.slice.call(rootNode.querySelectorAll('[data-cse*=\"encrypted\"]')).map(f => f.getAttribute('data-cse'));\n    }\n    return [];\n};\n\n/**\n * If, visually, we're dealing with a single date field (expiryDate) we still need separate entries\n * for expiryMonth & expiryYear - since that is how the values will be delivered from securedFields\n */\nexport const validFieldsReducer = (acc, cur) => {\n    if (cur === ENCRYPTED_EXPIRY_DATE) {\n        acc[ENCRYPTED_EXPIRY_MONTH] = false;\n        acc[ENCRYPTED_EXPIRY_YEAR] = false;\n    } else {\n        acc[cur] = false;\n    }\n\n    return acc;\n};\n// -- end ROUTINES USED IN SecuredFieldsProvider.componentDidMount --------------------------------\n\n// ROUTINES USED IN SecuredFieldsProvider.showValidation TO GENERATE ERRORS ///////////\n/**\n *  If, visually, we're dealing with a single date field (expiryDate) remap the separate entries we have\n *  for the valid states of expiryMonth & expiryYear back to the single key we use to an store an error\n *  i.e `\"encryptedExpiryMonth\" & \"encryptedExpiryYear\" => \"encryptedExpiryDate\"`\n */\nconst mapDateFields = (field, numDateFields) => {\n    const isDateField = field === ENCRYPTED_EXPIRY_MONTH || field === ENCRYPTED_EXPIRY_YEAR;\n    return numDateFields === 1 && isDateField ? ENCRYPTED_EXPIRY_DATE : field;\n};\n\n/**\n * Skip generating an error for an optional field, unless it is already in error\n */\nconst skipOptionalFields = (field, state, fieldNames) => {\n    // console.log('\\n### utils::skipOptionalField3:: examining field=', field);\n    const { isFieldOfType, fieldIsValid } = fieldNames.reduce(\n        (acc, fieldName) => {\n            if (!acc.isFieldOfType) {\n                // console.log('### utils:: fieldName:: ', fieldName, 'match=', field === fieldName);\n                acc.isFieldOfType = field === fieldName;\n                acc.fieldIsValid = !state.errors[fieldName];\n            }\n            return acc;\n        },\n        { isFieldOfType: false, fieldIsValid: false }\n    );\n\n    const policyType = field === ENCRYPTED_SECURITY_CODE ? 'cvcPolicy' : 'expiryDatePolicy';\n\n    const policyOptional = policyType === 'cvcPolicy' ? CVC_POLICY_OPTIONAL : DATE_POLICY_OPTIONAL;\n    const policyHidden = policyType === 'cvcPolicy' ? CVC_POLICY_HIDDEN : DATE_POLICY_HIDDEN;\n\n    // if policy != required\n    return (state[policyType] === policyOptional || state[policyType] === policyHidden) && fieldIsValid && isFieldOfType ? null : field;\n};\n\nexport const getErrorReducer = (numDateFields, state) => (acc, field) => {\n    // We're only interested in the non-valid fields from the state.valid object...\n    let val =\n        state.valid[field] !== true\n            ? mapDateFields(field, numDateFields) // Map the keys we use for the valid state to the key(s) we use for the error state\n            : null;\n\n    // Skip error generation for optional/hidden CVC & Date unless the fields are already in error\n    val = skipOptionalFields(val, state, [ENCRYPTED_SECURITY_CODE, ENCRYPTED_EXPIRY_DATE, ENCRYPTED_EXPIRY_MONTH, ENCRYPTED_EXPIRY_YEAR]);\n\n    // console.log('### utils:::: ############# val=', val);\n\n    if (val && !acc.includes(val)) acc.push(val);\n\n    return acc;\n};\n\n/**\n * Create an object suitable for sending to our handleOnError function\n */\nexport const getErrorObject = (fieldType, rootNode, state) => {\n    // Get existing error OR field is empty in which case get field specific msg OR use default\n    const error = getProp(state, `errors.${fieldType}`) || EMPTY_FIELD_ERROR_MESSAGES[fieldType];\n    return {\n        rootNode,\n        fieldType,\n        error,\n        type: 'card'\n    };\n};\n// -- end ROUTINES USED IN SecuredFieldsProvider.showValidation -----------------------\n"],"names":["getFields","rootNode","Array","prototype","slice","call","querySelectorAll","map","f","getAttribute","validFieldsReducer","acc","cur","ENCRYPTED_EXPIRY_DATE","ENCRYPTED_EXPIRY_MONTH","ENCRYPTED_EXPIRY_YEAR","getErrorReducer","numDateFields","state","field","val","valid","mapDateFields","fieldNames","isFieldOfType","fieldIsValid","reduce","fieldName","errors","policyType","ENCRYPTED_SECURITY_CODE","policyOptional","CVC_POLICY_OPTIONAL","DATE_POLICY_OPTIONAL","policyHidden","CVC_POLICY_HIDDEN","DATE_POLICY_HIDDEN","skipOptionalFields","includes","push","getErrorObject","fieldType","error","getProp","EMPTY_FIELD_ERROR_MESSAGES","type"],"mappings":"gXAiBaA,MAAAA,EAAYC,GACjBA,EACOC,MAAMC,UAAUC,MAAMC,KAAKJ,EAASK,iBAAiB,4BAA4BC,KAAIC,GAAKA,EAAEC,aAAa,cAE7G,GAOEC,EAAqB,CAACC,EAAKC,KAChCA,IAAQC,GACRF,EAAIG,IAA0B,EAC9BH,EAAII,IAAyB,GAE7BJ,EAAIC,IAAO,EAGRD,GAyCEK,EAAkB,CAACC,EAAeC,IAAU,CAACP,EAAKQ,KAE3D,IAAIC,GACuB,IAAvBF,EAAMG,MAAMF,GAlCE,EAACA,EAAOF,IAED,IAAlBA,GADaE,IAAUL,GAA0BK,IAAUJ,EACEI,EAAxBN,EAiClCS,CAAcH,EAAOF,GACrB,KASV,OANAG,EA/BuB,EAACD,EAAOD,EAAOK,KAEtC,MAAMC,cAAEA,EAAaC,aAAEA,GAAiBF,EAAWG,QAC/C,CAACf,EAAKgB,KACGhB,EAAIa,gBAELb,EAAIa,cAAgBL,IAAUQ,EAC9BhB,EAAIc,cAAgBP,EAAMU,OAAOD,IAE9BhB,IAEX,CAAEa,eAAe,EAAOC,cAAc,IAGpCI,EAAaV,IAAUW,EAA0B,YAAc,mBAE/DC,EAAgC,cAAfF,EAA6BG,EAAsBC,EACpEC,EAA8B,cAAfL,EAA6BM,EAAoBC,EAGtE,OAAQlB,EAAMW,KAAgBE,GAAkBb,EAAMW,KAAgBK,IAAiBT,GAAgBD,EAAgB,KAAOL,CAAAA,EAWxHkB,CAAmBjB,EAAKF,EAAO,CAACY,EAAyBjB,EAAuBC,EAAwBC,IAI1GK,IAAQT,EAAI2B,SAASlB,IAAMT,EAAI4B,KAAKnB,GAEjCT,CAAAA,EAME6B,EAAiB,CAACC,EAAWxC,EAAUiB,KAGzC,CACHjB,WACAwC,YACAC,MAJUC,EAAQzB,EAAO,UAAUuB,MAAgBG,EAA2BH,GAK9EI,KAAM"}