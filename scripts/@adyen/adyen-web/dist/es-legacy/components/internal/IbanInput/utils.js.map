{"version":3,"file":"utils.js","sources":["../../../../../src/components/internal/IbanInput/utils.ts"],"sourcesContent":["import countries from './specifications';\n\n/**\n * Parse the BBAN structure used to configure each IBAN __specification and returns a matching regular expression.\n * A structure is composed of blocks of 3 characters (one letter and 2 digits). Each block represents\n * a logical group in the typical representation of the BBAN. For each group, the letter indicates which characters\n * are allowed in this group and the following 2-digits number tells the length of the group.\n *\n * @param structure - the structure to parse\n * @param countryCode - the countryCode to check format against\n *\n * @internal\n */\nexport const parseStructure = (structure, countryCode) => {\n    if (countryCode === null || !countries[countryCode] || !countries[countryCode].structure) {\n        return false;\n    }\n\n    const passedStructure = countries[countryCode].structure;\n\n    // split in blocks of 3 chars\n    const regex = passedStructure.match(/(.{3})/g).map(block => {\n        // parse each structure block (1-char + 2-digits)\n        const pattern = block.slice(0, 1);\n        const repeats = parseInt(block.slice(1), 10);\n        let format;\n\n        switch (pattern) {\n            case 'A':\n                format = '0-9A-Za-z';\n                break;\n            case 'B':\n                format = '0-9A-Z';\n                break;\n            case 'C':\n                format = 'A-Za-z';\n                break;\n            case 'F':\n                format = '0-9';\n                break;\n            case 'L':\n                format = 'a-z';\n                break;\n            case 'U':\n                format = 'A-Z';\n                break;\n            case 'W':\n                format = '0-9a-z';\n                break;\n            default:\n                break;\n        }\n\n        return `([${format}]{${repeats}})`;\n    });\n\n    return new RegExp(`^${regex.join('')}$`);\n};\n\n/**\n * @internal\n */\nexport const formatIban = iban =>\n    iban\n        .replace(/\\W/gi, '')\n        .replace(/(.{4})(?!$)/g, '$1 ')\n        .trim();\n\nexport type ElectronicFormat = string;\n/**\n * Returns any non alphanumeric characters and uppercases them\n *\n * @internal\n */\nexport const electronicFormat = (iban: string): ElectronicFormat => {\n    const NON_ALPHANUM = /[^a-zA-Z0-9]/g;\n    return iban.replace(NON_ALPHANUM, '').toUpperCase();\n};\n\n/**\n * Lazy-loaded regex (parse the structure and construct the regular expression the first time we need it for validation)\n *\n * @internal\n */\nexport const regex = (iban, countryCode) => parseStructure(iban, countryCode);\n\n/**\n * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to\n * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.\n * @param ibanInput - The IBAN value\n * @returns The prepared IBAN\n *\n * @internal\n */\nexport const iso13616Prepare = ibanInput => {\n    let iban = ibanInput;\n    const A = 'A'.charCodeAt(0);\n    const Z = 'Z'.charCodeAt(0);\n    iban = iban.toUpperCase();\n    iban = iban.substr(4) + iban.substr(0, 4);\n\n    return iban\n        .split('')\n        .map(n => {\n            const code = n.charCodeAt(0);\n\n            if (code >= A && code <= Z) {\n                // A = 10, B = 11, ... Z = 35\n                const codeA = code - A;\n                return codeA + 10;\n            }\n\n            return n;\n        })\n        .join('');\n};\n\n/**\n * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.\n *\n * @param iban -\n *\n * @internal\n */\nexport const iso7064Mod97_10 = iban => {\n    let remainder = iban;\n    let block;\n\n    while (remainder.length > 2) {\n        block = remainder.slice(0, 9);\n        remainder = (parseInt(block, 10) % 97) + remainder.slice(block.length);\n    }\n\n    return parseInt(remainder, 10) % 97;\n};\n\n/**\n *  @param countryCode -\n *  @returns Example of IBAN Number\n */\nexport const getIbanPlaceHolder = (countryCode = null) => {\n    if (countryCode && countries[countryCode] && countries[countryCode].example) {\n        return formatIban(countries[countryCode].example);\n    }\n\n    return 'AB00 1234 5678 9012 3456 7890';\n};\n\nexport const getIbanCountrySpecification = countryCode => {\n    if (countryCode && countries[countryCode]) {\n        return countries[countryCode];\n    }\n\n    return false;\n};\n\n/**\n *  @param cursor -\n *  @param iban -\n *  @param previousIban -\n *  @returns new cursor position\n */\nexport const getNextCursorPosition = (cursor, iban, previousIban) => {\n    if (cursor === 0 || !iban.length) return 0;\n\n    // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n    // we know the user in this instance pasted two characters\n    const editLength = iban.length - previousIban.length;\n    const isAddition = editLength > 0;\n    const isMaskChar = (ibanValue, position) => /\\s/.test(ibanValue.charAt(position));\n    const initialCursor = cursor - editLength;\n\n    // is adding text, check calculate if there was a mask element after the initial cursor, then move cursor forward\n    // example: NL13 ABNA| 1234 5678 9 => NL13 ABNA 0|123 4567 89\n    if (isAddition && (isMaskChar(iban, initialCursor + 1) || isMaskChar(iban, initialCursor))) {\n        return cursor + 1;\n    }\n\n    // is removing text, check if the previous is a mask character, then move cursor back\n    // example: NL13 ABNA 0|123 4567 89 => NL13 ABNA| 1234 5678 9\n    if (!isAddition && isMaskChar(iban, cursor - 1)) {\n        return cursor - 1;\n    }\n\n    return cursor;\n};\n\n/**\n * @param electronicFormatIban -\n * @returns countryCode string\n */\nexport const getCountryCode = (electronicFormatIban: ElectronicFormat) => electronicFormatIban.slice(0, 2);\n"],"names":["parseStructure","structure","countryCode","countries","regex","match","map","block","pattern","slice","repeats","parseInt","format","RegExp","join","formatIban","iban","replace","trim","electronicFormat","toUpperCase","iso13616Prepare","ibanInput","A","charCodeAt","Z","substr","split","n","code","iso7064Mod97_10","remainder","length","getIbanCountrySpecification","getNextCursorPosition","cursor","previousIban","editLength","isAddition","isMaskChar","ibanValue","position","test","charAt","initialCursor","getCountryCode","electronicFormatIban"],"mappings":"mCAaO,MAAMA,EAAiB,CAACC,EAAWC,KACtC,GAAoB,OAAhBA,IAAyBC,EAAUD,KAAiBC,EAAUD,GAAaD,UAC3E,OAAO,EAGX,MAGMG,EAHkBD,EAAUD,GAAaD,UAGjBI,MAAM,WAAWC,KAAIC,IAE/C,MAAMC,EAAUD,EAAME,MAAM,EAAG,GACzBC,EAAUC,SAASJ,EAAME,MAAM,GAAI,IACzC,IAAIG,EAEJ,OAAQJ,GACJ,IAAK,IACDI,EAAS,YACT,MACJ,IAAK,IACDA,EAAS,SACT,MACJ,IAAK,IACDA,EAAS,SACT,MACJ,IAAK,IACDA,EAAS,MACT,MACJ,IAAK,IACDA,EAAS,MACT,MACJ,IAAK,IACDA,EAAS,MACT,MACJ,IAAK,IACDA,EAAS,SAMjB,MAAO,KAAKA,MAAWF,KAAW,IAGtC,OAAO,IAAIG,OAAO,IAAIT,EAAMU,KAAK,OAAM,EAM9BC,EAAaC,GACtBA,EACKC,QAAQ,OAAQ,IAChBA,QAAQ,eAAgB,OACxBC,OAQIC,EAAoBH,GAEtBA,EAAKC,QADS,gBACa,IAAIG,cAQ7BhB,EAAQ,CAACY,EAAMd,IAAgBF,EAAegB,EAAMd,GAUpDmB,EAAkBC,IAC3B,IAAIN,EAAOM,EACX,MAAMC,EAAI,IAAIC,WAAW,GACnBC,EAAI,IAAID,WAAW,GAIzB,OAHAR,EAAOA,EAAKI,cACZJ,EAAOA,EAAKU,OAAO,GAAKV,EAAKU,OAAO,EAAG,GAEhCV,EACFW,MAAM,IACNrB,KAAIsB,IACD,MAAMC,EAAOD,EAAEJ,WAAW,GAE1B,GAAIK,GAAQN,GAAKM,GAAQJ,EAAG,CAGxB,OADcI,EAAON,EACN,EACnB,CAEA,OAAOK,CAAAA,IAEVd,KAAK,GAAA,EAUDgB,EAAkBd,IAC3B,IACIT,EADAwB,EAAYf,EAGhB,KAAOe,EAAUC,OAAS,GACtBzB,EAAQwB,EAAUtB,MAAM,EAAG,GAC3BsB,EAAapB,SAASJ,EAAO,IAAM,GAAMwB,EAAUtB,MAAMF,EAAMyB,QAGnE,OAAOrB,SAASoB,EAAW,IAAM,EAAA,EAexBE,EAA8B/B,MACnCA,IAAeC,EAAUD,KAClBC,EAAUD,GAYZgC,EAAwB,CAACC,EAAQnB,EAAMoB,KAChD,GAAe,IAAXD,IAAiBnB,EAAKgB,OAAQ,OAAO,EAIzC,MAAMK,EAAarB,EAAKgB,OAASI,EAAaJ,OACxCM,EAAaD,EAAa,EAC1BE,EAAa,CAACC,EAAWC,IAAa,KAAKC,KAAKF,EAAUG,OAAOF,IACjEG,EAAgBT,EAASE,EAI/B,OAAIC,IAAeC,EAAWvB,EAAM4B,EAAgB,IAAML,EAAWvB,EAAM4B,IAChET,EAAS,GAKfG,GAAcC,EAAWvB,EAAMmB,EAAS,GAClCA,EAAS,EAGbA,CAAAA,EAOEU,EAAkBC,GAA2CA,EAAqBrC,MAAM,EAAG"}