{"version":3,"file":"validator-utils.js","sources":["../../../src/utils/validator-utils.ts"],"sourcesContent":["import { CountryFormatRules } from './Validator/types';\n\nconst MAX_LENGTH = 30;\n\nexport const getMaxLengthByFieldAndCountry = (\n    formattingRules: CountryFormatRules,\n    field: string,\n    country: string,\n    ignoreIfFormatterExists: boolean\n): number | null => {\n    // In ignoreIfFormatterExists is true we expect the formatter function to also act to limit length\n    if (ignoreIfFormatterExists && formattingRules[country]?.[field]?.formatterFn) {\n        return null;\n    }\n    const maxLength = formattingRules[country]?.[field]?.maxlength;\n    return maxLength ? maxLength : MAX_LENGTH;\n};\n\n// Not null or undefined or only spaces\nexport const isEmpty = input => !!(input == null || /^[\\s]*$/.test(input));\n\nexport const isString = input => typeof input === 'string' || input instanceof String;\nexport const hasText = input => isString(input) && !isEmpty(input);\n\nexport const SPECIAL_CHARS = '?\\\\+_=!@#$%^&*(){}~<>\\\\[\\\\]\\\\\\\\'; // N.B. difficulty escaping \\ (takes 3 backslashes!)\n\n// Generates a regEx ideal for use in a String.replace call for use in a formatter\n// e.g. getFormattingRegEx('^\\\\d', 'g') will generate: /[^\\d]/g which is a regEx to match anything that is not a digit\nexport const getFormattingRegEx = (specChars: string, flags = 'g') => new RegExp(`[${specChars}]`, flags);\n\n// Creates a regEx ideal for use in a RegExp.test call for use in a validator\nexport const getValidatingRegEx = (specChars: string, exclude: boolean) => new RegExp(`^[${exclude ? '^' : ''}${specChars}]+$`);\n\nexport const CHARACTER_PATTERNS: { [key: string]: RegExp } = {\n    digitsHyphen: /^[\\d-]+$/,\n    noHtml: /^[^<>&]+$/,\n    alphaNum: /^\\d[a-zA-Z0-9]{6,11}$/,\n    noSpecialChars: getValidatingRegEx(SPECIAL_CHARS, true)\n};\n\nexport const exactLength = (input: string, length: number) => {\n    if (isEmpty(input)) {\n        return true;\n    }\n    return input.length === length;\n};\n\nexport const validateForSpecialChars = name => {\n    const hasNoLength = !name.length;\n    // RegEx .test, if run against empty string, will return false\n    return CHARACTER_PATTERNS.noSpecialChars.test(name) || hasNoLength;\n};\n\n// Trim start and never allow more than 1 space on the end\nexport const trimValWithOneSpace = (val: string) => val.trimStart().replace(/\\s+/g, ' ');\n"],"names":["getMaxLengthByFieldAndCountry","formattingRules","field","country","ignoreIfFormatterExists","formatterFn","maxLength","maxlength","MAX_LENGTH","isEmpty","input","test","SPECIAL_CHARS","getFormattingRegEx","specChars","flags","RegExp","trimValWithOneSpace","val","trimStart","replace"],"mappings":"AAEA,MAEaA,EAAgC,CACzCC,EACAC,EACAC,EACAC,KAG+BH,IAAAA,EAAAA,EAGbA,EAAAA,EAHlB,GAA+BA,QAAAA,EAAAA,EAAgBE,UAAhBF,IAAAA,GAAiC,QAAjCA,EAAAA,EAA2BC,UAA3BD,IAAAA,OAAAA,EAAAA,EAAmCI,YAC9D,OAAO,KAEX,MAAMC,EAAYL,QAAAA,EAAAA,EAAgBE,UAAhBF,IAAAA,GAAAA,QAAAA,EAAAA,EAA2BC,UAA3BD,IAAAA,OAAAA,EAAAA,EAAmCM,UACrD,OAAOD,GAbQ,EAagBE,EAItBC,EAAUC,KAAqB,MAATA,IAAiB,UAAUC,KAAKD,IAKtDE,EAAgB,kCAIhBC,EAAqB,CAACC,EAAmBC,EAAQ,MAAQ,IAAIC,OAAO,IAAIF,KAAcC,GA0BtFE,EAAuBC,GAAgBA,EAAIC,YAAYC,QAAQ,OAAQ"}