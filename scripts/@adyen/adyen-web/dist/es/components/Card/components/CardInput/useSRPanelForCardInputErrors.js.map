{"version":3,"file":"useSRPanelForCardInputErrors.js","sources":["../../../../../../src/components/Card/components/CardInput/useSRPanelForCardInputErrors.ts"],"sourcesContent":["import { useEffect, useState } from 'preact/hooks';\nimport useSRPanelContext from '../../../../core/Errors/useSRPanelContext';\nimport { SetSRMessagesReturnFn } from '../../../../core/Errors/SRPanelProvider';\nimport { handlePartialAddressMode, lookupBlurBasedErrors, mapFieldKey } from './utils';\nimport { usePrevious } from '../../../../utils/hookUtils';\nimport { SetSRMessagesReturnObject, SortedErrorObject } from '../../../../core/Errors/types';\nimport { ERROR_ACTION_BLUR_SCENARIO, ERROR_ACTION_FOCUS_FIELD } from '../../../../core/Errors/constants';\nimport { setFocusOnFirstField } from './handlers';\nimport { getArrayDifferences } from '../../../../utils/arrayUtils';\n\nconst useSRPanelForCardInputErrors = ({ errors, props, isValidating, retrieveLayout, specifications, billingAddress, sfp }) => {\n    // Extract fns from context\n    const { setSRMessagesFromObjects, setSRMessagesFromStrings, clearSRPanel, shouldMoveFocusSR } = useSRPanelContext();\n\n    // Generate a setSRMessages function - implemented as a partial, since the initial set of arguments don't change.\n    const setSRMessages: SetSRMessagesReturnFn = setSRMessagesFromObjects?.({\n        fieldTypeMappingFn: mapFieldKey\n    });\n\n    const partialAddressSchema = handlePartialAddressMode(props.billingAddressMode);\n\n    const [sortedErrorList, setSortedErrorList] = useState<SortedErrorObject[]>(null);\n\n    // Get the previous list of errors\n    const previousSortedErrors = usePrevious(sortedErrorList);\n\n    const sfStateErrorsObj = sfp.current?.mapErrorsToValidationRuleResult();\n    const mergedErrors = { ...errors, ...sfStateErrorsObj };\n\n    useEffect(() => {\n        try {\n            // Extract and then flatten billingAddress errors into a new object with *all* the field errors at top level\n            const { billingAddress: extractedAddressErrors, ...errorsWithoutAddress } = mergedErrors;\n\n            const errorsForPanel = { ...errorsWithoutAddress, ...extractedAddressErrors };\n\n            // Pass dynamic props (errors, layout etc) to SRPanel via partial\n            const srPanelResp: SetSRMessagesReturnObject = setSRMessages?.({\n                errors: errorsForPanel,\n                isValidating: isValidating.current,\n                layout: retrieveLayout(),\n                // If we don't have country specific address labels, we might have a label related to a partialAddressSchema (i.e. zipCode)\n                countrySpecificLabels: specifications.getAddressLabelsForCountry(billingAddress?.country) ?? partialAddressSchema?.default?.labels\n            });\n\n            // Store the array of sorted error objects separately so that we can use it to make comparisons between the old and new arrays\n            const currentErrorsSortedByLayout = srPanelResp?.currentErrorsSortedByLayout;\n            setSortedErrorList(currentErrorsSortedByLayout);\n\n            /**\n             * Need extra actions after setting SRPanel messages in order to focus field (if required) and because we have some errors that are fired onBlur\n             */\n            switch (srPanelResp?.action) {\n                // A call to focus the first field in error will always follow the call to validate the whole form\n                case ERROR_ACTION_FOCUS_FIELD:\n                    if (shouldMoveFocusSR) setFocusOnFirstField(isValidating.current, sfp, srPanelResp?.fieldToFocus);\n                    // Remove 'showValidation' mode - allowing time for collation of all the fields in error whilst it is 'showValidation' mode (some errors come in a second render pass)\n                    setTimeout(() => {\n                        isValidating.current = false;\n                    }, 300);\n                    break;\n\n                /**\n                 * Relates to errors triggered by a field blurring (some pm forms have this, some don't) - check if there is an error to either set or to clear\n                 */\n                case ERROR_ACTION_BLUR_SCENARIO: {\n                    const difference = getArrayDifferences<SortedErrorObject, string>(currentErrorsSortedByLayout, previousSortedErrors, 'field');\n\n                    const latestErrorMsg = difference?.[0];\n\n                    if (latestErrorMsg) {\n                        // Use the error code to look up whether error is actually a blur based one (most are but some SF ones aren't)\n                        const isBlurBasedError = lookupBlurBasedErrors(latestErrorMsg.errorCode);\n\n                        /**\n                         *  ONLY ADD BLUR BASED ERRORS TO THE ERROR PANEL - doing this step prevents the non-blur based errors from being read out twice\n                         *  (once from the aria-live, error panel & once from the aria-describedby element)\n                         */\n                        const latestSRError = isBlurBasedError ? latestErrorMsg.errorMessage : null;\n                        // console.log('### CardInput2::componentDidUpdate:: #2 (not validating) single error:: latestSRError', latestSRError);\n                        setSRMessagesFromStrings(latestSRError);\n                    } else {\n                        // called when previousSortedErrors.length >= currentErrorsSortedByLayout.length\n                        // console.log('### CardInput2::componentDidUpdate:: #3(not validating) clearing errors:: NO latestErrorMsg');\n                        clearSRPanel();\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        } catch (_) {\n            // We don't handle the error related to the sr panel, let it fail silently.\n        }\n    }, [errors]);\n\n    return { sortedErrorList, previousSortedErrors, clearSRPanel };\n};\n\nexport default useSRPanelForCardInputErrors;\n"],"names":["useSRPanelForCardInputErrors","errors","props","isValidating","retrieveLayout","specifications","billingAddress","sfp","setSRMessagesFromObjects","setSRMessagesFromStrings","clearSRPanel","shouldMoveFocusSR","useSRPanelContext","setSRMessages","fieldTypeMappingFn","mapFieldKey","partialAddressSchema","handlePartialAddressMode","billingAddressMode","sortedErrorList","setSortedErrorList","useState","previousSortedErrors","usePrevious","sfStateErrorsObj","current","mapErrorsToValidationRuleResult","mergedErrors","useEffect","extractedAddressErrors","errorsWithoutAddress","errorsForPanel","srPanelResp","layout","countrySpecificLabels","getAddressLabelsForCountry","country","default","labels","currentErrorsSortedByLayout","action","ERROR_ACTION_FOCUS_FIELD","setFocusOnFirstField","fieldToFocus","setTimeout","ERROR_ACTION_BLUR_SCENARIO","difference","getArrayDifferences","latestErrorMsg","latestSRError","lookupBlurBasedErrors","errorCode","errorMessage","_"],"mappings":"giBAUA,MAAMA,EAA+B,EAAGC,SAAQC,QAAOC,eAAcC,iBAAgBC,iBAAgBC,iBAAgBC,UAEjH,MAAMC,yBAAEA,EAAwBC,yBAAEA,EAAwBC,aAAEA,EAAYC,kBAAEA,GAAsBC,IAG1FC,EAAuCL,IAA2B,CACpEM,mBAAoBC,IAGlBC,EAAuBC,EAAyBf,EAAMgB,qBAErDC,EAAiBC,GAAsBC,EAA8B,MAGtEC,EAAuBC,EAAYJ,GAEnCK,EAAmBjB,EAAIkB,SAASC,kCAChCC,EAAe,IAAK1B,KAAWuB,GAqErC,OAnEAI,GAAU,KACN,IAEI,MAAQtB,eAAgBuB,KAA2BC,GAAyBH,EAEtEI,EAAiB,IAAKD,KAAyBD,GAG/CG,EAAyCnB,IAAgB,CAC3DZ,OAAQ8B,EACR5B,aAAcA,EAAasB,QAC3BQ,OAAQ7B,IAER8B,sBAAuB7B,EAAe8B,2BAA2B7B,GAAgB8B,UAAYpB,GAAsBqB,SAASC,SAI1HC,EAA8BP,GAAaO,4BAMjD,OALAnB,EAAmBmB,GAKXP,GAAaQ,QAEjB,KAAKC,EACG9B,GAAmB+B,EAAqBvC,EAAasB,QAASlB,EAAKyB,GAAaW,cAEpFC,YAAW,KACPzC,EAAasB,SAAU,CAAA,GACxB,KACH,MAKJ,KAAKoB,EAA4B,CAC7B,MAAMC,EAAaC,EAA+CR,EAA6BjB,EAAsB,SAE/G0B,EAAiBF,IAAa,GAEpC,GAAIE,EAAgB,CAEhB,MAMMC,EANmBC,EAAsBF,EAAeG,WAMrBH,EAAeI,aAAe,KAEvE3C,EAAyBwC,QAIzBvC,IAEJ,KACJ,EAIR,CAAE,MAAO2C,GAET,IACD,CAACpD,IAEG,CAAEkB,kBAAiBG,uBAAsBZ,eAAa"}