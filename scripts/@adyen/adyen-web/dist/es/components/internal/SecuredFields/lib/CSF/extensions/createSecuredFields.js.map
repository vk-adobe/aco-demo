{"version":3,"file":"createSecuredFields.js","sources":["../../../../../../../../src/components/internal/SecuredFields/lib/CSF/extensions/createSecuredFields.ts"],"sourcesContent":["import { select, getAttribute } from '../../utilities/dom';\nimport {\n    ENCRYPTED_EXPIRY_YEAR,\n    DATE_POLICY_REQUIRED,\n    CVC_POLICY_REQUIRED,\n    DATA_ENCRYPTED_FIELD_ATTR,\n    DATA_INFO,\n    DATA_UID,\n    SF_CONFIG_TIMEOUT,\n    ALL_SECURED_FIELDS,\n    ENCRYPTED_EXPIRY_MONTH\n} from '../../constants';\nimport { existy } from '../../../../../../utils/commonUtils';\nimport cardType from '../utils/cardType';\nimport { SecuredFieldSetupObject } from '../../types';\nimport SecuredField from '../../securedField/SecuredField';\nimport { CardObject, CardBrandData, SFFeedbackObj, CardLoadData, CVCPolicyType, DatePolicyType } from '../../types';\nimport AdyenCheckoutError from '../../../../../../core/Errors/AdyenCheckoutError';\nimport type { SFKeyPressObj } from '../../types';\n\n/**\n * Bound to the instance of CSF\n * Handles specific functionality related to configuring & creating SecuredFields\n */\nexport function createSecuredFields(): number {\n    this.encryptedAttrName = DATA_ENCRYPTED_FIELD_ATTR;\n\n    // Detect DOM elements that qualify as securedField holders & filter them for valid types\n    const securedFields: HTMLElement[] = select(this.props.rootNode, `[${this.encryptedAttrName}]`).filter(field => {\n        const fieldType: string = getAttribute(field, this.encryptedAttrName);\n\n        if (fieldType === ENCRYPTED_EXPIRY_MONTH) {\n            // TODO send analytics about separate date fields\n        }\n\n        const isValidType = ALL_SECURED_FIELDS.includes(fieldType);\n        if (!isValidType) {\n            console.warn(\n                `WARNING: '${fieldType}' is not a valid type for the '${this.encryptedAttrName}' attribute. A SecuredField will not be created for this element.`\n            );\n        }\n        return isValidType;\n    });\n\n    /**\n     * cvcPolicy - 'required' | 'optional' | 'hidden'\n     * - Always 'required' for GiftCards\n     * - Usually 'required' for single branded Credit Cards but with exceptions e.g. maestro ('optional'), bcmc ('hidden').\n     * - Always 'required' for generic Credit Cards at start up - in this case, subsequent, supporting information about whether cvc stops being required\n     * comes from the SF in the brand information (as the shopper inputs the cc number)\n     */\n    const cvcPolicy: CVCPolicyType = CVC_POLICY_REQUIRED;\n\n    /** Usually 'required' for single branded Credit Cards but with exceptions e.g. ticket ('hidden', *technically* a meal voucher) */\n    const expiryDatePolicy: DatePolicyType = DATE_POLICY_REQUIRED;\n\n    // CHECK IF THIS SECURED FIELD IS NOT OF A CREDIT CARD TYPE\n    if (!this.config.isCreditCardType) {\n        this.createNonCardSecuredFields(securedFields);\n        return securedFields.length;\n    }\n\n    // CONTINUE AS CREDIT-CARD TYPE...\n    this.isSingleBrandedCard = false;\n\n    this.securityCode = '';\n\n    this.createCardSecuredFields(securedFields, cvcPolicy, expiryDatePolicy);\n\n    // Return the number of iframes we're going to create\n    return securedFields.length;\n}\n\n/**\n * i.e. giftcard and ach fields\n *\n * Create a new SecuredField for each detected holding element\n */\nexport async function createNonCardSecuredFields(securedFields: HTMLElement[]): Promise<any> {\n    for (let i = 0; i < securedFields.length; i++) {\n        const securedField = securedFields[i];\n        await this.setupSecuredField(securedField).catch(e => {\n            if (window._b$dl) console.log('Secured fields setup failure. e=', e);\n        });\n    }\n}\n\nexport async function createCardSecuredFields(\n    securedFields: HTMLElement[],\n    cvcPolicy: CVCPolicyType,\n    expiryDatePolicy: DatePolicyType\n): Promise<any> {\n    // Declared card type from the initialisation of CSF\n    let type: string = this.state.type;\n\n    // Maybe it's a single branded card defined by setting type: 'card' & a single item in cardGroupTypes\n    // In which case update the type var both locally AND in State\n    if (type === 'card' && this.config.cardGroupTypes.length === 1) {\n        type = this.config.cardGroupTypes[0];\n        this.state.type = type;\n    }\n\n    // So, is it a single branded card?\n    this.isSingleBrandedCard = type !== 'card';\n\n    // If single branded card field...\n    if (this.isSingleBrandedCard) {\n        // Check that type exists\n        const card: CardObject = cardType.getCardByBrand(type);\n\n        // It's possible we don't recognise the card type -\n        // scenario: frontend initially recognises card as e.g. Visa - but then backend tokenises it as a sub-brand which we currently don't recognise\n        if (!existy(card)) {\n            this.state.type = 'unrecognised-single-brand'; // Will let CVC field accept 4 digits in the input\n        } else {\n            // Assess whether cvc field is required based on the card type & whether the cvc field should even be visible\n            cvcPolicy = card.cvcPolicy || CVC_POLICY_REQUIRED;\n            expiryDatePolicy = card.expiryDatePolicy || DATE_POLICY_REQUIRED;\n\n            this.securityCode = card.securityCode;\n        }\n    }\n\n    /**\n     * Create a new SecuredField for each detected holding element\n     *\n     * - we do this in sequence, waiting until one has configured before creating the next.\n     * We do it this way to avoid the 'bug' whereby if something interrupts the loading of an iframe the listener we have for its load event\n     * never fires; which means the iframe never configures.\n     * (NB - you can recreate this 'bug' by creating the securedFields in a synchronous loop:\n     *      securedFields.forEach(this.setupSecuredField.bind(this));\n     *  and putting a breakpoint on the line where we declare the setupSecuredField function)\n     *\n     *  Also note we tried the Array.map/Promise.all way of asynchronously looping through an array - but it didn't fix the issue,\n     *  - so we fall back to a good old for-loop\n     */\n    for (let i = 0; i < securedFields.length; i++) {\n        const securedField = securedFields[i];\n        if (window._b$dl) console.log('\\nAbout to set up securedField:', securedField);\n        await this.setupSecuredField(securedField, cvcPolicy, expiryDatePolicy).catch(e => {\n            if (window._b$dl) console.log('Secured fields setup failure. e=', e);\n        });\n        if (window._b$dl) console.log('Finished setting up securedField:', securedField);\n    }\n    if (window._b$dl) console.log('Finished setting up all securedFields');\n\n    /**\n     * Now the securedFields have all been created and configured...\n     *\n     * For a single branded card we call to onBrand callback once.\n     * This allows the UI to set the correct logo if they haven't already,\n     * and we also pass the cvcPolicy & expiryDatePolicy so the UI can hide the iframe holders if necessary\n     */\n    if (this.isSingleBrandedCard) {\n        const callbackObj: CardBrandData = {\n            type: this.state.type,\n            rootNode: this.props.rootNode,\n            brand: type,\n            cvcPolicy,\n            expiryDatePolicy,\n            cvcText: this.securityCode\n        };\n\n        // Allow a tick for the securedField to finish rendering\n        setTimeout(() => {\n            this.callbacks.onBrand(callbackObj);\n        }, 0);\n    }\n}\n\n// Run for each detected holder of a securedField...\nexport function setupSecuredField(pItem: HTMLElement, cvcPolicy?: CVCPolicyType, expiryDatePolicy?: DatePolicyType): Promise<any> {\n    return new Promise((resolve, reject) => {\n        /**\n         *  possible values:\n         *  encryptedCardNumber\n         *  encryptedExpiryDate\n         *  encryptedExpiryMonth\n         *  encryptedExpiryYear\n         *  encryptedSecurityCode\n         *  encryptedPassword\n         *  encryptedPin???\n         *  encryptedBankAccountNumber\n         *  encryptedBankLocationId\n         *  encryptedIBAN\n         */\n        const fieldType: string = getAttribute(pItem, this.encryptedAttrName);\n\n        if (fieldType === ENCRYPTED_EXPIRY_YEAR) {\n            this.state.hasSeparateDateFields = true;\n        }\n\n        const extraFieldData: string = getAttribute(pItem, DATA_INFO);\n        const uid = getAttribute(pItem, DATA_UID);\n\n        // CREATE SecuredField passing config object\n        const sfInitObj: SecuredFieldSetupObject = {\n            fieldType,\n            extraFieldData,\n            uid,\n            cvcPolicy,\n            holderEl: pItem,\n            expiryDatePolicy,\n            txVariant: this.state.type,\n            // from this.config (calculated)\n            cardGroupTypes: this.config.cardGroupTypes,\n            iframeUIConfig: this.config.iframeUIConfig,\n            sfLogAtStart: this.config.sfLogAtStart,\n            trimTrailingSeparator: this.config.trimTrailingSeparator,\n            isCreditCardType: this.config.isCreditCardType,\n            iframeSrc: this.config.iframeSrc,\n            loadingContext: this.config.loadingContext,\n            showWarnings: this.config.showWarnings,\n            legacyInputMode: this.config.legacyInputMode,\n            minimumExpiryDate: this.config.minimumExpiryDate,\n            // from this.props (passed straight thru)\n            maskSecurityCode: this.props.maskSecurityCode,\n            exposeExpiryDate: this.props.exposeExpiryDate,\n            disableIOSArrowKeys: this.props.shouldDisableIOSArrowKeys,\n            implementationType: this.props.implementationType,\n            showContextualElement: this.props.showContextualElement,\n            placeholders: this.props.placeholders\n        };\n\n        const sf: SecuredField = new SecuredField(sfInitObj, this.props.i18n)\n            .onIframeLoaded((): void => {\n                // Count\n                this.state.iframeCount += 1;\n\n                if (window._b$dl) console.log('### createSecuredFields::onIframeLoaded:: this.state.iframeCount=', this.state.iframeCount);\n\n                // One of our existing securedFields has just loaded new content!\n                if (this.state.iframeCount > this.state.numIframes) {\n                    this.destroySecuredFields();\n                    // TODO send analytics about this error\n                    throw new AdyenCheckoutError(\n                        'ERROR',\n                        `One or more securedFields has just loaded new content. This should never happen. securedFields have been removed.\n                        iframe load count=${this.state.iframeCount}. Expected count:${this.state.numIframes}`\n                    );\n                }\n\n                /** Create timeout within which time we expect the securedField to configure */\n                // @ts-ignore - timeout 'type' *is* a number\n                sf.loadToConfigTimeout = setTimeout(() => {\n                    reject({ type: sfInitObj.fieldType, failReason: 'sf took too long to config' });\n                }, SF_CONFIG_TIMEOUT);\n\n                // If all iframes are loaded - call onLoad callback\n                if (this.state.iframeCount === this.state.originalNumIframes) {\n                    const callbackObj: CardLoadData = { iframesLoaded: true };\n                    this.callbacks.onLoad(callbackObj);\n                }\n            })\n            .onConfig((pFeedbackObj: SFFeedbackObj): void => {\n                this.handleIframeConfigFeedback(pFeedbackObj);\n\n                // Clear timeout since the securedField has configured\n                clearTimeout(sf.loadToConfigTimeout);\n                sf.loadToConfigTimeout = null;\n\n                resolve(pFeedbackObj);\n            })\n            .onFocus((pFeedbackObj: SFFeedbackObj): void => {\n                this.handleFocus(pFeedbackObj);\n            })\n            .onBinValue((pFeedbackObj: SFFeedbackObj): void => {\n                this.handleBinValue(pFeedbackObj);\n            })\n            .onTouchstart((pFeedbackObj: SFFeedbackObj): void => {\n                // re. Disabling arrow keys in iOS - need to disable all other fields in the form\n                if (this.props.shouldDisableIOSArrowKeys) {\n                    /**\n                     * re. this.hasGenuineTouchEvents...\n                     *  There seems to be an issue with Responsive Design mode in Safari that means it allows setting focus on cross-origin iframes,\n                     *  without enabling the touch events that allow the \"disableIOSArrowKeys\" workaround to fully function.\n                     *  This results in a click on an securedFields *label* leading to, for example, the holderName field being disabled, but w/o access\n                     *  to the touch events that would let it re-enable itself.\n                     *\n                     *  So we prevent the \"disableIOSArrowKeys\" workaround unless we genuinely have touch events available.\n                     */\n                    if (this.hasGenuineTouchEvents || pFeedbackObj.hasGenuineTouchEvents) {\n                        this.callbacks.onTouchstartIOS({ fieldType: pFeedbackObj.fieldType });\n                    }\n                }\n\n                // Only perform this step if we genuinely have touch events available\n                if (pFeedbackObj.hasGenuineTouchEvents || this.hasGenuineTouchEvents) {\n                    // iOS ONLY - RE. iOS BUGS AROUND BLUR AND FOCUS EVENTS\n                    // - pass information about which field has just been clicked (gained focus) to the other iframes\n                    this.postMessageToAllIframes({ fieldType: pFeedbackObj.fieldType, fieldClick: true });\n                }\n            })\n            .onShiftTab((pFeedbackObj: SFFeedbackObj): void => {\n                // Only happens for Firefox & IE <= 11\n                this.handleSFShiftTab(pFeedbackObj.fieldType);\n            })\n            .onEncryption((pFeedbackObj: SFFeedbackObj): void => {\n                this.handleEncryption(pFeedbackObj);\n            })\n            .onValidation((pFeedbackObj: SFFeedbackObj): void => {\n                this.handleValidation(pFeedbackObj);\n            })\n            .onAutoComplete((pFeedbackObj: SFFeedbackObj): void => {\n                this.processAutoComplete(pFeedbackObj);\n            })\n            .onKeyPressed((pFeedbackObj: SFFeedbackObj): void => {\n                const { numKey, ...rest } = pFeedbackObj;\n                this.callbacks.onKeyPressed(rest as SFKeyPressObj);\n            });\n\n        // Store reference to securedField in this.state (under fieldType)\n        this.state.securedFields[fieldType] = sf;\n    });\n}\n"],"names":["createSecuredFields","this","encryptedAttrName","DATA_ENCRYPTED_FIELD_ATTR","securedFields","select","props","rootNode","filter","field","fieldType","getAttribute","isValidType","ALL_SECURED_FIELDS","includes","console","warn","cvcPolicy","CVC_POLICY_REQUIRED","expiryDatePolicy","DATE_POLICY_REQUIRED","config","isCreditCardType","isSingleBrandedCard","securityCode","createCardSecuredFields","length","createNonCardSecuredFields","async","i","securedField","setupSecuredField","catch","e","window","_b$dl","log","type","state","cardGroupTypes","card","cardType","getCardByBrand","existy","callbackObj","brand","cvcText","setTimeout","callbacks","onBrand","pItem","Promise","resolve","reject","ENCRYPTED_EXPIRY_YEAR","hasSeparateDateFields","sfInitObj","extraFieldData","DATA_INFO","uid","DATA_UID","holderEl","txVariant","iframeUIConfig","sfLogAtStart","trimTrailingSeparator","iframeSrc","loadingContext","showWarnings","legacyInputMode","minimumExpiryDate","maskSecurityCode","exposeExpiryDate","disableIOSArrowKeys","shouldDisableIOSArrowKeys","implementationType","showContextualElement","placeholders","sf","SecuredField","i18n","onIframeLoaded","iframeCount","numIframes","destroySecuredFields","AdyenCheckoutError","loadToConfigTimeout","failReason","SF_CONFIG_TIMEOUT","originalNumIframes","iframesLoaded","onLoad","onConfig","pFeedbackObj","handleIframeConfigFeedback","clearTimeout","onFocus","handleFocus","onBinValue","handleBinValue","onTouchstart","hasGenuineTouchEvents","onTouchstartIOS","postMessageToAllIframes","fieldClick","onShiftTab","handleSFShiftTab","onEncryption","handleEncryption","onValidation","handleValidation","onAutoComplete","processAutoComplete","onKeyPressed","numKey","rest"],"mappings":"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"}