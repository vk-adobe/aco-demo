{"version":3,"file":"processBrand.js","sources":["../../../../../../../../src/components/internal/SecuredFields/lib/CSF/partials/processBrand.ts"],"sourcesContent":["import { ENCRYPTED_CARD_NUMBER, ENCRYPTED_SECURITY_CODE } from '../../constants';\nimport postMessageToIframe from '../utils/iframes/postMessageToIframe';\nimport { objectsDeepEqual } from '../../utilities/commonUtils';\nimport { BrandStorageObject, CardBrandData, SFFeedbackObj, SFFieldType } from '../../types';\nimport { pick } from '../../../../../../utils/commonUtils';\nimport { hasOwnProperty } from '../../../../../../utils/hasOwnProperty';\nimport getIframeContentWin from '../utils/iframes/getIframeContentWin';\nimport { CSFThisObject } from '../types';\n\nconst checkForBrandChange = (pBrand: BrandStorageObject, storedBrand: BrandStorageObject): boolean => {\n    // if the objects aren't the same - then return true = brandChange has happened\n    return !objectsDeepEqual(pBrand, storedBrand);\n};\n\n/**\n * - If generic card type AND passed brand doesn't equal stored brand - send the new brand to the cvc input\n *    (so it can reassess what length it should be and if any value it contains is now valid)\n *\n * - Create object for onBrand callback aka SFPHandlers.handleOnBrand\n *\n * @param csfState - comes from initial, partial, implementation\n * @param csfConfig - comes from initial, partial, implementation\n * @param csfProps - comes from initial, partial, implementation\n * @param csfCallbacks - comes from initial, partial, implementation\n *\n * @param pFeedbackObj -\n */\nexport default function processBrand({ csfState, csfConfig, csfProps, csfCallbacks }: CSFThisObject, pFeedbackObj: SFFeedbackObj): boolean {\n    const fieldType: SFFieldType = pFeedbackObj.fieldType;\n\n    if (fieldType === ENCRYPTED_CARD_NUMBER) {\n        // Check for new brand...\n        const newBrandObj: BrandStorageObject = {\n            brand: pFeedbackObj.brand,\n            cvcPolicy: pFeedbackObj.cvcPolicy,\n            expiryDatePolicy: pFeedbackObj.expiryDatePolicy,\n            showSocialSecurityNumber: pFeedbackObj.showSocialSecurityNumber\n        };\n        const newBrand: boolean = checkForBrandChange(newBrandObj, csfState.brand);\n\n        if (!newBrand) {\n            return null;\n        }\n\n        // Now BCMC can dual brand with Visa it must also be treated as a generic card so we can show/hide the CVC field\n        const treatAsGenericCard: boolean = csfState.type === 'card' || csfState.type === 'bcmc';\n\n        // ...if also a generic card - tell cvc field...\n        if (treatAsGenericCard && newBrand) {\n            // Store on state so for subsequent brand messages we can compare the new and the old\n            csfState.brand = newBrandObj;\n\n            // Perform postMessage to send brand to CVC field - this also needs to happen for BCMC, single branded cards,\n            // because it needs to know the cvcPolicy (to set the aria-required attribute & to show the iframe)\n            if (hasOwnProperty(csfState.securedFields, ENCRYPTED_SECURITY_CODE)) {\n                const dataObj: object = {\n                    txVariant: csfState.type,\n                    brand: newBrandObj.brand,\n                    fieldType: ENCRYPTED_SECURITY_CODE,\n                    cvcPolicy: pFeedbackObj.cvcPolicy,\n                    numKey: csfState.securedFields[ENCRYPTED_SECURITY_CODE].numKey\n                };\n                postMessageToIframe(dataObj, getIframeContentWin(csfState, ENCRYPTED_SECURITY_CODE), csfConfig.loadingContext);\n            }\n        }\n\n        // Create object with brand related properties\n        const brandInfoObj = treatAsGenericCard\n            ? pick(['brand', 'cvcPolicy', 'cvcText', 'expiryDatePolicy', 'showSocialSecurityNumber']).from(pFeedbackObj)\n            : null;\n\n        if (brandInfoObj && brandInfoObj.brand) {\n            const callbackObj: CardBrandData = brandInfoObj as CardBrandData;\n            callbackObj.type = csfState.type;\n            callbackObj.rootNode = csfProps.rootNode as HTMLElement;\n\n            // ...and call SFPHandlers.handleOnBrand\n            csfCallbacks.onBrand(callbackObj);\n        }\n\n        return true;\n    }\n\n    return false;\n}\n"],"names":["processBrand","csfState","csfConfig","csfProps","csfCallbacks","pFeedbackObj","fieldType","ENCRYPTED_CARD_NUMBER","newBrandObj","brand","cvcPolicy","expiryDatePolicy","showSocialSecurityNumber","newBrand","pBrand","storedBrand","objectsDeepEqual","treatAsGenericCard","type","hasOwnProperty","securedFields","ENCRYPTED_SECURITY_CODE","dataObj","txVariant","numKey","postMessageToIframe","getIframeContentWin","loadingContext","brandInfoObj","pick","from","callbackObj","rootNode","onBrand"],"mappings":"iZA2Be,SAASA,GAAaC,SAAEA,EAAQC,UAAEA,EAASC,SAAEA,EAAQC,aAAEA,GAA+BC,GAGjG,GAF+BA,EAAaC,YAE1BC,EAAuB,CAErC,MAAMC,EAAkC,CACpCC,MAAOJ,EAAaI,MACpBC,UAAWL,EAAaK,UACxBC,iBAAkBN,EAAaM,iBAC/BC,yBAA0BP,EAAaO,0BAErCC,GA7BeC,EA6ByBN,EA7BGO,EA6BUd,EAASQ,OA3BhEO,EAAiBF,EAAQC,IA6B7B,IAAKF,EACD,OAAO,KAIX,MAAMI,EAAgD,SAAlBhB,EAASiB,MAAqC,SAAlBjB,EAASiB,KAGzE,GAAID,GAAsBJ,IAEtBZ,EAASQ,MAAQD,EAIbW,EAAelB,EAASmB,cAAeC,IAA0B,CACjE,MAAMC,EAAkB,CACpBC,UAAWtB,EAASiB,KACpBT,MAAOD,EAAYC,MACnBH,UAAWe,EACXX,UAAWL,EAAaK,UACxBc,OAAQvB,EAASmB,cAAcC,GAAyBG,QAE5DC,EAAoBH,EAASI,EAAoBzB,EAAUoB,GAA0BnB,EAAUyB,eACnG,CAIJ,MAAMC,EAAeX,EACfY,EAAK,CAAC,QAAS,YAAa,UAAW,mBAAoB,6BAA6BC,KAAKzB,GAC7F,KAEN,GAAIuB,GAAgBA,EAAanB,MAAO,CACpC,MAAMsB,EAA6BH,EACnCG,EAAYb,KAAOjB,EAASiB,KAC5Ba,EAAYC,SAAW7B,EAAS6B,SAGhC5B,EAAa6B,QAAQF,EACzB,CAEA,OAAO,CACX,CAxEwB,IAACjB,EAA4BC,EA0ErD,OAAO,CACX"}