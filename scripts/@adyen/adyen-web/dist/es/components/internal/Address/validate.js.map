{"version":3,"file":"validate.js","sources":["../../../../../src/components/internal/Address/validate.ts"],"sourcesContent":["import { ValidatorRules, ValidatorRule } from '../../../utils/Validator/types';\nimport { countrySpecificFormatters } from './validate.formats';\nimport { ERROR_FIELD_REQUIRED, ERROR_INVALID_FORMAT_EXPECTS } from '../../../core/Errors/constants';\nimport { isEmpty } from '../../../utils/validator-utils';\n\nconst createPatternByDigits = (digits: number) => {\n    return {\n        pattern: new RegExp(`\\\\d{${digits}}`)\n    };\n};\n\nexport const validatePostalCode = (val: string, countryCode: string, validatorRules: ValidatorRules) => {\n    if (countryCode) {\n        // If there is no value, we display the 'required' error message\n        if (isEmpty(val)) return null;\n\n        // Dynamically create errorMessage\n        (validatorRules.postalCode as ValidatorRule).errorMessage = {\n            translationKey: ERROR_INVALID_FORMAT_EXPECTS,\n            translationObject: {\n                values: {\n                    format: countrySpecificFormatters[countryCode]?.postalCode.format || null\n                }\n            }\n        };\n\n        const pattern = postalCodePatterns[countryCode]?.pattern;\n        return pattern ? pattern.test(val) : !!val; // No pattern? Accept any, filled, value.\n    }\n    // Default rule\n    return isEmpty(val) ? null : true;\n};\n\nconst postalCodePatterns = {\n    AT: createPatternByDigits(4),\n    AU: createPatternByDigits(4),\n    BE: { pattern: /(?:(?:[1-9])(?:\\d{3}))/ },\n    BG: createPatternByDigits(4),\n    BR: { pattern: /^\\d{5}-?\\d{3}$/ },\n    CA: { pattern: /(?:[ABCEGHJ-NPRSTVXY]\\d[A-Z][ -]?\\d[A-Z]\\d)/ },\n    CH: { pattern: /[1-9]\\d{3}/ },\n    CY: createPatternByDigits(4),\n    CZ: { pattern: /\\d{3}\\s?\\d{2}/ },\n    DE: createPatternByDigits(5),\n    DK: createPatternByDigits(4),\n    EE: createPatternByDigits(5),\n    ES: { pattern: /(?:0[1-9]|[1-4]\\d|5[0-2])\\d{3}/ },\n    FI: createPatternByDigits(5),\n    FR: createPatternByDigits(5),\n    GB: { pattern: /^([A-Za-z][A-Ha-hK-Yk-y]?[0-9][A-Za-z0-9]? ?[0-9][A-Za-z]{2}|[Gg][Ii][Rr] ?0[Aa]{2})$/ },\n    GE: createPatternByDigits(4),\n    GR: { pattern: /^\\d{3}\\s{0,1}\\d{2}$/ },\n    HR: { pattern: /^([1-5])[0-9]{4}$/ },\n    HU: createPatternByDigits(4),\n    IE: { pattern: /(?:^[AC-FHKNPRTV-Y][0-9]{2}|D6W)[ -]?[0-9AC-FHKNPRTV-Y]{4}/ },\n    IS: createPatternByDigits(3),\n    IT: createPatternByDigits(5),\n    LI: createPatternByDigits(4),\n    LT: { pattern: /^(LT-\\d{5}|\\d{4,5})$/ },\n    LU: createPatternByDigits(4),\n    LV: { pattern: /^(LV-)[0-9]{4}$/ },\n    MC: { pattern: /^980\\d{2}$/ },\n    MT: { pattern: /^[A-Za-z]{3}\\d{4}$/ },\n    MY: createPatternByDigits(5),\n    NL: { pattern: /(?:NL-)?(?:[1-9]\\d{3} ?(?:[A-EGHJ-NPRTVWXZ][A-EGHJ-NPRSTVWXZ]|S[BCEGHJ-NPRTVWXZ]))/ },\n    NO: createPatternByDigits(4),\n    PL: { pattern: /^\\d{2}[-]{0,1}\\d{3}$/ },\n    PT: { pattern: /^([1-9]\\d{3})([- ]?(\\d{3})? *)$/ },\n    RO: createPatternByDigits(6),\n    SI: createPatternByDigits(4),\n    SE: createPatternByDigits(5),\n    SG: createPatternByDigits(6),\n    SK: createPatternByDigits(5),\n    US: createPatternByDigits(5)\n};\n\n/**\n * Validates only postalCode property. As the partial address form does not have the country selector, the country value\n * must be informed beforehand and can't be picked up from the form context\n *\n * @param country - Country that will be used to validate postal code\n */\nexport const getPartialAddressValidationRules = (country: string): ValidatorRules => {\n    const validationRules: ValidatorRules = {\n        postalCode: {\n            modes: ['blur'],\n            validate: val => {\n                return validatePostalCode(val, country, validationRules);\n            },\n            errorMessage: ERROR_FIELD_REQUIRED\n        }\n    };\n    return validationRules;\n};\n\nexport const getAddressValidationRules = (specifications): ValidatorRules => {\n    const addressValidationRules: ValidatorRules = {\n        postalCode: {\n            modes: ['blur'],\n            validate: (val, context) => {\n                const country = context.state.data.country;\n                return validatePostalCode(val, country, addressValidationRules);\n            },\n            errorMessage: ERROR_FIELD_REQUIRED\n        },\n        houseNumberOrName: {\n            validate: (value, context) => {\n                const selectedCountry = context.state?.data?.country;\n                const isOptional = selectedCountry && specifications.countryHasOptionalField(selectedCountry, 'houseNumberOrName');\n                return isOptional || (isEmpty(value) ? null : true);\n            },\n            modes: ['blur'],\n            errorMessage: ERROR_FIELD_REQUIRED\n        },\n        default: {\n            validate: value => (isEmpty(value) ? null : true), // true, if there are chars other than spaces\n            modes: ['blur'],\n            errorMessage: ERROR_FIELD_REQUIRED\n        }\n    };\n    return addressValidationRules;\n};\n"],"names":["createPatternByDigits","digits","pattern","RegExp","validatePostalCode","val","countryCode","validatorRules","isEmpty","postalCode","errorMessage","translationKey","ERROR_INVALID_FORMAT_EXPECTS","translationObject","values","format","countrySpecificFormatters","postalCodePatterns","test","AT","AU","BE","BG","BR","CA","CH","CY","CZ","DE","DK","EE","ES","FI","FR","GB","GE","GR","HR","HU","IE","IS","IT","LI","LT","LU","LV","MC","MT","MY","NL","NO","PL","PT","RO","SI","SE","SG","SK","US","getPartialAddressValidationRules","country","validationRules","modes","validate","ERROR_FIELD_REQUIRED","getAddressValidationRules","specifications","addressValidationRules","context","state","data","houseNumberOrName","value","selectedCountry","countryHasOptionalField","default"],"mappings":"yOAKA,MAAMA,EAAyBC,IACpB,CACHC,QAAS,IAAIC,OAAO,OAAOF,QAItBG,EAAqB,CAACC,EAAaC,EAAqBC,KACjE,GAAID,EAAa,CAEb,GAAIE,EAAQH,GAAM,OAAO,KAGxBE,EAAeE,WAA6BC,aAAe,CACxDC,eAAgBC,EAChBC,kBAAmB,CACfC,OAAQ,CACJC,OAAQC,EAA0BV,IAAcG,WAAWM,QAAU,QAKjF,MAAMb,EAAUe,EAAmBX,IAAcJ,QACjD,OAAOA,EAAUA,EAAQgB,KAAKb,KAASA,CAC3C,CAEA,OAAOG,EAAQH,IAAO,IAAO,EAG3BY,EAAqB,CACvBE,GAAInB,EAAsB,GAC1BoB,GAAIpB,EAAsB,GAC1BqB,GAAI,CAAEnB,QAAS,0BACfoB,GAAItB,EAAsB,GAC1BuB,GAAI,CAAErB,QAAS,kBACfsB,GAAI,CAAEtB,QAAS,+CACfuB,GAAI,CAAEvB,QAAS,cACfwB,GAAI1B,EAAsB,GAC1B2B,GAAI,CAAEzB,QAAS,iBACf0B,GAAI5B,EAAsB,GAC1B6B,GAAI7B,EAAsB,GAC1B8B,GAAI9B,EAAsB,GAC1B+B,GAAI,CAAE7B,QAAS,kCACf8B,GAAIhC,EAAsB,GAC1BiC,GAAIjC,EAAsB,GAC1BkC,GAAI,CAAEhC,QAAS,yFACfiC,GAAInC,EAAsB,GAC1BoC,GAAI,CAAElC,QAAS,uBACfmC,GAAI,CAAEnC,QAAS,qBACfoC,GAAItC,EAAsB,GAC1BuC,GAAI,CAAErC,QAAS,8DACfsC,GAAIxC,EAAsB,GAC1ByC,GAAIzC,EAAsB,GAC1B0C,GAAI1C,EAAsB,GAC1B2C,GAAI,CAAEzC,QAAS,wBACf0C,GAAI5C,EAAsB,GAC1B6C,GAAI,CAAE3C,QAAS,mBACf4C,GAAI,CAAE5C,QAAS,cACf6C,GAAI,CAAE7C,QAAS,sBACf8C,GAAIhD,EAAsB,GAC1BiD,GAAI,CAAE/C,QAAS,sFACfgD,GAAIlD,EAAsB,GAC1BmD,GAAI,CAAEjD,QAAS,wBACfkD,GAAI,CAAElD,QAAS,mCACfmD,GAAIrD,EAAsB,GAC1BsD,GAAItD,EAAsB,GAC1BuD,GAAIvD,EAAsB,GAC1BwD,GAAIxD,EAAsB,GAC1ByD,GAAIzD,EAAsB,GAC1B0D,GAAI1D,EAAsB,IASjB2D,EAAoCC,IAC7C,MAAMC,EAAkC,CACpCpD,WAAY,CACRqD,MAAO,CAAC,QACRC,SAAU1D,GACCD,EAAmBC,EAAKuD,EAASC,GAE5CnD,aAAcsD,IAGtB,OAAOH,CAAAA,EAGEI,EAA6BC,IACtC,MAAMC,EAAyC,CAC3C1D,WAAY,CACRqD,MAAO,CAAC,QACRC,SAAU,CAAC1D,EAAK+D,KACZ,MAAMR,EAAUQ,EAAQC,MAAMC,KAAKV,QACnC,OAAOxD,EAAmBC,EAAKuD,EAASO,EAAAA,EAE5CzD,aAAcsD,GAElBO,kBAAmB,CACfR,SAAU,CAACS,EAAOJ,KACd,MAAMK,EAAkBL,EAAQC,OAAOC,MAAMV,QAE7C,OADmBa,GAAmBP,EAAeQ,wBAAwBD,EAAiB,uBACxEjE,EAAQgE,IAAS,IAAU,EAErDV,MAAO,CAAC,QACRpD,aAAcsD,GAElBW,QAAS,CACLZ,SAAUS,IAAUhE,EAAQgE,IAAS,KACrCV,MAAO,CAAC,QACRpD,aAAcsD,IAGtB,OAAOG,CAAAA"}