/*! Copyright 2025 Adobe
All Rights Reserved. */
import{initializeConfig as o,getConfigValue as s,getRootPath as n,getListOfRootPaths as c,isMultistore as u,getHeaders as a,resetConfig as f}from"./configs.js";import"../../chunks/cjs.js";import"../../chunks/get-path-value.js";describe("AEM Config",()=>{const t={public:{default:{headers:{all:{"x-test":"test"},commerce:{"x-commerce":"commerce"}}}}};beforeEach(()=>{i("/"),f()}),afterEach(()=>{jest.clearAllMocks(),jest.restoreAllMocks()}),test("should initialize config (default)",()=>{const e={public:{default:{foo:"bar"}}},l=o(e);expect(l).toEqual(e.public.default)}),test("should initialize config with default config if root path is not found",()=>{i("/not-found/");const e=o(t);expect(e).toEqual(t.public.default)}),test("should initialize config with default config if root path is empty",()=>{i("/sub-path/");const e=o({...t,public:{...t.public,"/sub-path/":{}}});expect(e).toEqual(t.public.default)}),test("should initialize config with overrides if root path is not empty",()=>{i("/sub-path/");const e=o({...t,public:{...t.public,"/sub-path/":{headers:{all:{"x-test":"test2"}}}}});expect(e).toEqual({headers:{all:{"x-test":"test2"},commerce:{"x-commerce":"commerce"}}})}),test("should throw error if no config is initialized",async()=>{expect(()=>s("foo")).toThrow("Configuration not initialized. Call initializeConfig() first.")}),test("should get config value",async()=>{o({public:{default:{foo:"bar"}}}),expect(s("foo")).toBe("bar")}),test("should get config value from root path",()=>{i("/sub-path/"),o({...t,public:{...t.public,"/sub-path/":{foo:"baz",nested:{foo:"nested"}}}}),expect(s("headers.all.x-test")).toBe("test"),expect(s("foo")).toBe("baz"),expect(s("nested.foo")).toBe("nested")}),test("should warn if value is not found",async()=>{const e=jest.spyOn(console,"warn").mockImplementation(()=>{});o(t),s("foo.bar"),expect(e).toHaveBeenCalledWith("Property foo.bar does not exist in the object")}),test("should warn if the root path has no config",async()=>{const e=jest.spyOn(console,"warn").mockImplementation(()=>{}),l=n(null);expect(l).toBe("/"),expect(e).toHaveBeenCalledWith("No config found. Please call initializeConfig() first.")}),test("should warn if the root path is not found",async()=>{i("/no-found/");const e=n({public:{default:{}}});expect(e).toBe("/")}),test("should get default root path",async()=>{i("/path/"),o(t),expect(n()).toBe("/")}),test("should get root path from public config",async()=>{i("/test/"),o({...t,public:{...t.public,"/test/":{}}}),expect(n()).toBe("/test/")}),test("should get list of root paths",async()=>{o({...t,public:{...t.public,"/test/":{},"/test2/":{}}}),expect(c()).toEqual(["/test/","/test2/"])}),test("should warn if list of root paths has no config",async()=>{const e=jest.spyOn(console,"warn").mockImplementation(()=>{}),l=c();expect(e).toHaveBeenCalledWith("No config found. Please call initializeConfig() first."),expect(l).toEqual([])}),test("should check if multistore",async()=>{o(t),expect(u()).toBe(!1),o({...t,public:{...t.public,"/test/":{}}}),expect(u()).toBe(!0)}),test("should throw error if headers are not initialized",async()=>{expect(()=>a("all")).toThrow("Configuration not initialized. Call initializeConfig() first.")}),test("should get headers",async()=>{o(t),expect(a("all")).toEqual(t.public.default.headers.all),expect(a("commerce")).toEqual({...t.public.default.headers.all,...t.public.default.headers.commerce})}),test('should get "all" headers if no config is found',async()=>{o(t),expect(a("not-found")).toEqual({...t.public.default.headers.all})}),test("should get empty headers if no config is found",async()=>{o({public:{default:{}}}),expect(a("not-found")).toEqual({})})});function i(t){Object.defineProperty(window,"location",{value:{pathname:t,origin:"http://localhost"}})}
//# sourceMappingURL=configs.test.js.map
