{"version":3,"file":"configs.js","sources":["/@dropins/tools/src/lib/aem/configs.ts"],"sourcesContent":["import { deepmerge } from '../deepmerge';\nimport { getPathValue } from '../get-path-value';\n\ninterface ConfigHeaders {\n  all?: Record<string, string>;\n  [key: string]: Record<string, string> | undefined;\n}\n\ninterface ConfigPublic {\n  default: ConfigRoot;\n  [key: string]: ConfigRoot;\n}\n\ninterface ConfigRoot {\n  headers?: ConfigHeaders;\n  [key: string]: any;\n}\n\ninterface Config {\n  public: ConfigPublic;\n  [key: string]: any;\n}\n\n// Private state\nlet config: Config | null = null;\nlet rootPath: string | null = null;\nlet rootConfig: ConfigRoot | null = null;\n\n/**\n * Reset the config state\n */\nfunction resetConfig() {\n  config = null;\n  rootPath = null;\n  rootConfig = null;\n}\n\n/**\n * Get root path\n * @param {Object} [configObj=config] - The config object.\n * @returns {string} - The root path.\n */\nfunction getRootPath(configObj: Config | null = config): string {\n  if (!configObj) {\n    console.warn('No config found. Please call initializeConfig() first.');\n    return '/';\n  }\n\n  const value = Object.keys(configObj?.public)\n    // Sort by number of non-empty segments to find the deepest path\n    .sort((a, b) => {\n      const aSegments = a.split('/').filter(Boolean).length;\n      const bSegments = b.split('/').filter(Boolean).length;\n      return bSegments - aSegments;\n    })\n    .find(\n      (key) =>\n        window.location.pathname === key ||\n        window.location.pathname.startsWith(key)\n    );\n\n  return value ?? '/';\n}\n\n/**\n * Get list of root paths from public config\n * @returns {Array} - The list of root paths.\n */\nfunction getListOfRootPaths(): string[] {\n  if (!config) {\n    console.warn('No config found. Please call initializeConfig() first.');\n    return [];\n  }\n\n  return Object.keys(config.public).filter((root) => root !== 'default');\n}\n\n/**\n * Checks if the public config contains more than \"default\"\n * @returns {boolean} - true if public config contains more than \"default\"\n */\nfunction isMultistore(): boolean {\n  return getListOfRootPaths().length >= 1;\n}\n\n/**\n * Retrieves headers from config entries like commerce.headers.pdp.my-header, etc and\n * returns as object of all headers like { my-header: value, ... }\n * @param {string} scope - The scope of the headers to retrieve.\n * @returns {Object} - The headers.\n */\nfunction getHeaders(scope: string): Record<string, string> {\n  if (!rootConfig) {\n    throw new Error(\n      'Configuration not initialized. Call initializeConfig() first.'\n    );\n  }\n  const headers = rootConfig.headers ?? {};\n  return {\n    ...(headers.all ?? {}),\n    ...(headers[scope] ?? {}),\n  };\n}\n\n/**\n * Applies config overrides from metadata.\n *\n * @param {Object} [configObj] - The base config.\n * @param {string} [root] - The root path.\n * @returns {Object} - The config with overrides applied.\n */\nfunction applyConfigOverrides(\n  configObj: Config | null,\n  root: string | null\n): ConfigRoot {\n  const defaultConfig = configObj!.public?.default;\n\n  if (root === '/' || !configObj!.public[root as keyof ConfigPublic])\n    return defaultConfig;\n\n  return deepmerge(\n    defaultConfig,\n    configObj!.public[root as keyof ConfigPublic]\n  );\n}\n\n/**\n * Initializes the configuration system.\n * @returns {Object} The initialized root configuration\n */\nfunction initializeConfig(configObj: Config): ConfigRoot {\n  config = configObj;\n  rootPath = getRootPath(config);\n  rootConfig = applyConfigOverrides(config, rootPath);\n  return rootConfig;\n}\n\n/**\n * Retrieves a configuration value.\n *\n * @param {string} configParam - The configuration parameter to retrieve.\n * @returns {string|undefined} - The value of the configuration parameter, or undefined.\n */\nfunction getConfigValue(configParam: string): any {\n  if (!rootConfig) {\n    throw new Error(\n      'Configuration not initialized. Call initializeConfig() first.'\n    );\n  }\n  return getPathValue(rootConfig, configParam);\n}\n\nexport {\n  initializeConfig,\n  getRootPath,\n  getListOfRootPaths,\n  isMultistore,\n  getConfigValue,\n  getHeaders,\n  resetConfig,\n};\n"],"names":["config","rootPath","rootConfig","resetConfig","getRootPath","configObj","a","b","aSegments","key","getListOfRootPaths","root","isMultistore","getHeaders","scope","headers","applyConfigOverrides","defaultConfig","_a","deepmerge","initializeConfig","getConfigValue","configParam","getPathValue"],"mappings":"2FAwBA,IAAIA,EAAwB,KACxBC,EAA0B,KAC1BC,EAAgC,KAKpC,SAASC,GAAc,CACZH,EAAA,KACEC,EAAA,KACEC,EAAA,IACf,CAOA,SAASE,EAAYC,EAA2BL,EAAgB,CAC9D,OAAKK,EAKS,OAAO,KAAKA,GAAA,YAAAA,EAAW,MAAM,EAExC,KAAK,CAACC,EAAGC,IAAM,CACd,MAAMC,EAAYF,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO,EAAE,OAE/C,OADkBC,EAAE,MAAM,GAAG,EAAE,OAAO,OAAO,EAAE,OAC5BC,CACpB,CAAA,EACA,KACEC,GACC,OAAO,SAAS,WAAaA,GAC7B,OAAO,SAAS,SAAS,WAAWA,CAAG,CAC3C,GAEc,KAjBd,QAAQ,KAAK,wDAAwD,EAC9D,IAiBX,CAMA,SAASC,GAA+B,CACtC,OAAKV,EAKE,OAAO,KAAKA,EAAO,MAAM,EAAE,OAAQW,GAASA,IAAS,SAAS,GAJnE,QAAQ,KAAK,wDAAwD,EAC9D,CAAC,EAIZ,CAMA,SAASC,GAAwB,CACxB,OAAAF,EAAA,EAAqB,QAAU,CACxC,CAQA,SAASG,EAAWC,EAAuC,CACzD,GAAI,CAACZ,EACH,MAAM,IAAI,MACR,+DACF,EAEI,MAAAa,EAAUb,EAAW,SAAW,CAAC,EAChC,MAAA,CACL,GAAIa,EAAQ,KAAO,CAAC,EACpB,GAAIA,EAAQD,CAAK,GAAK,CAAA,CACxB,CACF,CASA,SAASE,EACPX,EACAM,EACY,OACN,MAAAM,GAAgBC,EAAAb,EAAW,SAAX,YAAAa,EAAmB,QAEzC,OAAIP,IAAS,KAAO,CAACN,EAAW,OAAOM,CAA0B,EACxDM,EAEFE,EACLF,EACAZ,EAAW,OAAOM,CAA0B,CAC9C,CACF,CAMA,SAASS,EAAiBf,EAA+B,CAC9C,OAAAL,EAAAK,EACTJ,EAAWG,EAAYJ,CAAM,EAChBE,EAAAc,EAAqBhB,EAAQC,CAAQ,EAC3CC,CACT,CAQA,SAASmB,EAAeC,EAA0B,CAChD,GAAI,CAACpB,EACH,MAAM,IAAI,MACR,+DACF,EAEK,OAAAqB,EAAarB,EAAYoB,CAAW,CAC7C"}