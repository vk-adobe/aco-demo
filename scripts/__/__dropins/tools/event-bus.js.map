{"version":3,"file":"event-bus.js","sources":["@dropins/tools/src/event-bus/index.ts"],"sourcesContent":["/********************************************************************\n *  Copyright 2024 Adobe\n *  All Rights Reserved.\n *\n * NOTICE:  Adobe permits you to use, modify, and distribute this \n * file in accordance with the terms of the Adobe license agreement \n * accompanying it. \n *******************************************************************/\n\nimport { Events } from './events-catalog';\n\nexport * from './events-catalog';\n\nconst hash = Date.now().toString(36).substring(2);\n\n/**\n * The `events` class provides static methods for event handling.\n * It allows subscribing to events, emitting events, and enabling or disabling event logging.\n *\n * @class\n * @extends {Events}\n *\n * @property {Function} on - Subscribes to an event.\n * @property {Function} emit - Emits an event.\n * @property {Function} enableLogger - Enables or disables event logging.\n * @property {Function} lastPayload - Returns the last payload of the event.\n */\nexport class events {\n  static _identifier = hash;\n\n  static _logger: BroadcastChannel | null = null;\n\n  static _lastEvent: { [key: string]: { payload: any } } = {};\n\n  /**\n   * Returns the last payload of the event.\n   * @param event â€“ The event to get the last payload from.\n   * @returns â€“ The last payload of the event.\n   */\n  static lastPayload(event: string) {\n    return this._lastEvent[event]?.payload;\n  }\n\n  /**\n   * Subscribes to an event.\n   * @param event - The event to subscribe to.\n   * @param handler - The event handler.\n   * @param options - Optional configuration for the event handler.\n   */\n  static on<K extends keyof Events>(\n    event: K,\n    handler: (payload: Events[K]) => void,\n    options?: { eager?: boolean }\n  ) {\n    if (typeof BroadcastChannel === 'undefined') {\n      return;\n    }\n\n    const subscriber = new BroadcastChannel('ElsieSDK/EventBus');\n\n    if (options?.eager) {\n      const lastEvent = this._lastEvent[event];\n\n      if (lastEvent) {\n        handler(lastEvent.payload);\n      }\n    }\n\n    subscriber.addEventListener('message', ({ data }) => {\n      // ignore events from other instances (only if identifier is set)\n      if (this._identifier && this._identifier !== data.identifier) return;\n\n      if (data.event === event) {\n        handler(data.payload);\n      }\n    });\n\n    // NOTE: disabled as it causes loading issues with \"bfcache\"\n    // unsubscribe if leaving page\n    // window.addEventListener('beforeunload', () => {\n    //   subscriber.close();\n    // });\n\n    return {\n      off() {\n        subscriber.close();\n      },\n    };\n  }\n  /**\n   * Emits an event.\n   * @param event - The event to emit.\n   * @param payload - The event payload.\n   */\n\n  static emit<K extends keyof Events>(event: K, payload: Events[K]) {\n    if (typeof BroadcastChannel === 'undefined') {\n      return;\n    }\n\n    const publisher = new BroadcastChannel('ElsieSDK/EventBus');\n\n    publisher.postMessage({ event, identifier: this._identifier, payload });\n\n    this._lastEvent[event] = {\n      payload,\n    };\n\n    publisher.close();\n  }\n  /**\n   * Enables or disables event logging.\n   * @param enabled - Whether to enable or disable event logging.\n   */\n  static enableLogger(enabled: boolean) {\n    if (typeof BroadcastChannel === 'undefined') {\n      return;\n    }\n\n    // reset logger\n    this._logger?.close();\n    this._logger = null;\n\n    if (enabled === false) return;\n\n    // create new logger\n    this._logger = new BroadcastChannel('ElsieSDK/EventBus');\n\n    this._logger.addEventListener('message', ({ data }) => {\n      if (this._identifier && this._identifier !== data.identifier) return;\n      console.group(`ðŸ“¡ Event (${data.identifier}) âž¡ ${data.event}`);\n      console.log(data.payload);\n      console.groupEnd();\n    });\n\n    // NOTE: disabled as it causes loading issues with \"bfcache\"\n    // unsubscribe if leaving page\n    // window.addEventListener('beforeunload', () => {\n    //   this._logger?.close();\n    // });\n  }\n}\n"],"names":["hash","events","event","_a","handler","options","subscriber","lastEvent","data","payload","publisher","enabled","__publicField"],"mappings":"oKAaA,MAAMA,EAAO,KAAK,IAAI,EAAE,SAAS,EAAE,EAAE,UAAU,CAAC,EAczC,MAAMC,CAAO,CAYlB,OAAO,YAAYC,EAAe,CA1BpC,IAAAC,EA2BW,OAAAA,EAAA,KAAK,WAAWD,CAAK,IAArB,YAAAC,EAAwB,OAAA,CASjC,OAAO,GACLD,EACAE,EACAC,EACA,CACI,GAAA,OAAO,iBAAqB,IAC9B,OAGI,MAAAC,EAAa,IAAI,iBAAiB,mBAAmB,EAE3D,GAAID,GAAA,MAAAA,EAAS,MAAO,CACZ,MAAAE,EAAY,KAAK,WAAWL,CAAK,EAEnCK,GACFH,EAAQG,EAAU,OAAO,CAC3B,CAGF,OAAAD,EAAW,iBAAiB,UAAW,CAAC,CAAE,KAAAE,KAAW,CAE/C,KAAK,aAAe,KAAK,cAAgBA,EAAK,YAE9CA,EAAK,QAAUN,GACjBE,EAAQI,EAAK,OAAO,CACtB,CACD,EAQM,CACL,KAAM,CACJF,EAAW,MAAM,CAAA,CAErB,CAAA,CAQF,OAAO,KAA6BJ,EAAUO,EAAoB,CAC5D,GAAA,OAAO,iBAAqB,IAC9B,OAGI,MAAAC,EAAY,IAAI,iBAAiB,mBAAmB,EAE1DA,EAAU,YAAY,CAAE,MAAAR,EAAO,WAAY,KAAK,YAAa,QAAAO,EAAS,EAEjE,KAAA,WAAWP,CAAK,EAAI,CACvB,QAAAO,CACF,EAEAC,EAAU,MAAM,CAAA,CAMlB,OAAO,aAAaC,EAAkB,CArGxC,IAAAR,EAsGQ,OAAO,iBAAqB,OAKhCA,EAAA,KAAK,UAAL,MAAAA,EAAc,QACd,KAAK,QAAU,KAEXQ,IAAY,KAGX,KAAA,QAAU,IAAI,iBAAiB,mBAAmB,EAEvD,KAAK,QAAQ,iBAAiB,UAAW,CAAC,CAAE,KAAAH,KAAW,CACjD,KAAK,aAAe,KAAK,cAAgBA,EAAK,aAClD,QAAQ,MAAM,aAAaA,EAAK,UAAU,OAAOA,EAAK,KAAK,EAAE,EACrD,QAAA,IAAIA,EAAK,OAAO,EACxB,QAAQ,SAAS,EAAA,CAClB,GAAA,CAQL,CAjHEI,EADWX,EACJ,cAAcD,GAErBY,EAHWX,EAGJ,UAAmC,MAE1CW,EALWX,EAKJ,aAAkD,CAAC"}